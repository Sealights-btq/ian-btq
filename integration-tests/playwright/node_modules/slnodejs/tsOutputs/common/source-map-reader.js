"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapReader = void 0;
const ConvertSourceMap = require("sl-convert-source-map");
const path = require("path");
const fs = require("fs");
const validation_utils_1 = require("./utils/validation-utils");
/**
 * Reads source map data from generated file, uses 'convert-source-map' packge to resolve.
 * If not found trying to search relevat map file under same directory as gem=nerated.
 */
class SourceMapReader {
    constructor(filename, logger, config) {
        this.config = config;
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(filename, 'filename');
        validation_utils_1.ValidationUtils.verifyNotNullOrEmpty(logger, 'logger');
        this.filename = filename;
        this.logger = logger;
    }
    readSourceMapData(generatedContent) {
        if (!generatedContent) {
            this.logger.debug('\'generatedContent\' cannot be null or empty');
            return null;
        }
        this.logger.debug(`About to resolve source map data for '${this.filename}'`);
        /**
        * When both inline source maps and .map files are present, we need to respect the preferSourceMapFromFile setting.
        * Previously, inline maps were always checked first, causing .map files to be ignored.
        * This array of readers allows us to control the order of source map resolution strategies.
        */
        const sourceMapReaders = [
            () => ConvertSourceMap.fromSource(generatedContent),
            () => ConvertSourceMap.fromMapFileSource(generatedContent, (filename) => {
                try {
                    const mapPath = path.resolve(path.dirname(this.filename), filename);
                    return fs.readFileSync(mapPath, 'utf-8');
                }
                catch (e) {
                    this.logger.error(`Failed to read source map file: ${filename}`, e);
                    return null;
                }
            })
        ];
        const preferSourceMapFromFile = this.config.preferSourceMapFromFile;
        if (preferSourceMapFromFile) {
            sourceMapReaders.reverse();
        }
        let sourceMapData = null;
        for (const reader of sourceMapReaders) {
            sourceMapData = reader();
            if (sourceMapData) {
                this.logger.info(`Found source map data for '${this.filename}'`);
                break;
            }
        }
        if (sourceMapData && sourceMapData.sourcemap) {
            this.logger.info(`Found source map data for '${this.filename}'`);
            return sourceMapData.sourcemap;
        }
        else {
            const mapFromFile = this.readFromFile();
            if (mapFromFile) {
                return mapFromFile;
            }
            else {
                if (this.isUsingSourceURL(generatedContent)) {
                    this.logger.info('Seems source map comment is in unsupported format...');
                }
                this.logger.debug(`Couldn't find source map data for '${this.filename}'`);
                return null;
            }
        }
    }
    readFromFile() {
        let sourceMap = null;
        const mapFileName = this.filename + SourceMapReader.MAP_FILE_EXTENSION;
        const isMapFileExists = fs.existsSync(mapFileName);
        if (!isMapFileExists) {
            this.logger.info(`File '${mapFileName}' not exists.`);
            return null;
        }
        this.logger.info(`Found map file '${mapFileName}'`);
        try {
            const rawMapData = fs.readFileSync(mapFileName).toString();
            sourceMap = JSON.parse(rawMapData);
            return sourceMap;
        }
        catch (e) {
            this.logger.error(`Could not parse source map data from '${path}`);
            this.logger.error(`Error: '${e}`);
            return null;
        }
    }
    /**
     *  The 'convert-source-map' detects only comments using 'sourceMappingURL' which is the new standard,
     some tools generate with comment 'sourceURL' which not supported
     */
    isUsingSourceURL(content) {
        const fileMatch = content.match(SourceMapReader.MAP_FILE_COMMENT_REGEX);
        const commentMatch = content.match(SourceMapReader.COMMENT_REGEX);
        return commentMatch !== null || fileMatch !== null;
    }
}
exports.SourceMapReader = SourceMapReader;
/*
    The following regex's based on regex used in 'convert-source-map' to detect source map.
    See https://github.com/thlorenz/convert-source-map/blob/master/index.js
 */
SourceMapReader.COMMENT_REGEX = /^\s*\/(?:\/|\*)[@#]\s+sourceURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
SourceMapReader.MAP_FILE_COMMENT_REGEX = /(?:\/\/[@#][ \t]+sourceURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
SourceMapReader.MAP_FILE_EXTENSION = '.map';
//# sourceMappingURL=source-map-reader.js.map