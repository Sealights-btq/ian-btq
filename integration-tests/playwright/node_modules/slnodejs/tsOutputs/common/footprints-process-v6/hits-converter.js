"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HitsConverter = void 0;
const sl_env_vars_1 = require("../constants/sl-env-vars");
const original_module_loader_1 = require("../coverage-elements/original-module-loader");
const hits_collector_1 = require("./hits-collector");
const new_id_resolver_1 = require("../coverage-elements/new-id-resolver");
const cockpit_notifier_1 = require("../agent-events/cockpit-notifier");
class HitsConverter {
    constructor(relativePathResolver, sourceMapData, projectRoot, logger, omitFootprintsLeadingSlash = false, enableLineCoverage = false) {
        this.enableLineCoverage = enableLineCoverage;
        this.conversionErrors = [];
        this._slMapping = {};
        this.relativePathResolver = relativePathResolver;
        this.sourceMapData = sourceMapData;
        this.omitFootprintsLeadingSlash = omitFootprintsLeadingSlash;
        this.projectRoot = projectRoot;
        this.logger = logger;
    }
    convertHits(hitFilesData) {
        let methodUniqueIds = [];
        let branchUniqueIds = [];
        let methodLineHits = {};
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            new original_module_loader_1.OriginalModuleLoader(hits_collector_1.HitsCollector.resolveGlobalCoverageObject(), this.logger).load();
        }
        hitFilesData.forEach(fileHit => {
            let relativePath = fileHit.filename;
            if (fileHit.shouldResolveRelativePath) {
                relativePath = this.relativePathResolver.getRelativePath(fileHit.filename);
            }
            const methodUniqueIdsWithPosition = this.createMethodIdsWithPosition(fileHit.hitMethods, relativePath, fileHit.filename, fileHit.uniqueIdKeysFromFile);
            methodUniqueIds = methodUniqueIds.concat(methodUniqueIdsWithPosition.map(method => method.uniqueId));
            branchUniqueIds = branchUniqueIds.concat(this.createBranchIds(fileHit.hitBranches, relativePath, fileHit.filename));
            if (this.enableLineCoverage) {
                methodLineHits = Object.assign(Object.assign({}, methodLineHits), this.convertMethodLineHits(methodUniqueIdsWithPosition, this.getUniqueHitLines(fileHit.hitStatements)));
            }
        });
        this.sendConversionErrors();
        return Object.assign({ branches: branchUniqueIds, methods: methodUniqueIds }, (this.enableLineCoverage && { methodLineHits }));
    }
    get slMapping() {
        return this._slMapping;
    }
    set slMapping(value) {
        this._slMapping = value;
    }
    setEnableLineCoverage(enableLineCoverage) {
        this.enableLineCoverage = enableLineCoverage;
    }
    convertMethodLineHits(methodUniqueIdsWithPosition, hitLines) {
        const methodLineHits = {};
        const methodLinesToUniqueIdsMap = this.combineMethodStartAndEndByLine(methodUniqueIdsWithPosition);
        hitLines.forEach(lineNumber => {
            const matchedMethods = methodLinesToUniqueIdsMap[lineNumber];
            matchedMethods === null || matchedMethods === void 0 ? void 0 : matchedMethods.forEach(matchedMethod => {
                methodLineHits[matchedMethod] = (methodLineHits[matchedMethod] || []).concat(lineNumber);
            });
        });
        return methodLineHits;
    }
    // Combine method start and end line from different methods starting on the same line to get the full range of lines covered by the methods
    // Returns a map of line number and the matching method unique ids that were hit
    combineMethodStartAndEndByLine(methodUniqueIdsWithPosition) {
        const methodStartAndEndByLine = {};
        methodUniqueIdsWithPosition.forEach(methodData => {
            const startLine = methodData.start.line;
            const endLine = methodData.end.line;
            // Create a range from the start until the end and assign the method id to the array
            for (let line = startLine; line <= endLine; line++) {
                if (!methodStartAndEndByLine[line]) {
                    methodStartAndEndByLine[line] = [];
                }
                methodStartAndEndByLine[line].push(methodData.uniqueId);
            }
        });
        return methodStartAndEndByLine;
    }
    getUniqueHitLines(hitStatements) {
        const uniqueLinesMap = new Set();
        hitStatements.forEach(statementData => {
            uniqueLinesMap.add(statementData.start.line);
        });
        return Array.from(uniqueLinesMap);
    }
    createMethodIdsWithPosition(hitFunctions, relativePath, absolutePath, uniqueIdKeysFromFile) {
        const methodsIdsWithPosition = [];
        hitFunctions.forEach(hit => {
            methodsIdsWithPosition.push({
                uniqueId: this.getMethodUniqueId(this.getStartLoc(hit), relativePath, absolutePath, uniqueIdKeysFromFile),
                start: hit.loc.start,
                end: hit.loc.end
            });
            if (this.getDecl(hit) && this.getDeclStart(hit)) {
                methodsIdsWithPosition.push({
                    uniqueId: this.getMethodUniqueId(this.getDeclStart(hit), relativePath, absolutePath, uniqueIdKeysFromFile),
                    start: hit.decl.start,
                    end: hit.decl.end
                });
            }
        });
        return methodsIdsWithPosition;
    }
    getDeclStart(hit) {
        return hit.decl.start;
    }
    getDecl(hit) {
        return hit.decl;
    }
    getStartLoc(hit) {
        return hit.loc.start;
    }
    getLeaveStartLoc(hit, leaveIdx, absolutePath) {
        var _a;
        const position = hit.branchData.locations[leaveIdx].start;
        const parentPosition = (_a = hit.branchData.loc) === null || _a === void 0 ? void 0 : _a.start;
        if (!parentPosition) {
            if (!sl_env_vars_1.SlEnvVars.isUseIstanbul()) {
                const message = `\'SL_useIstanbul\' was set to \'false\' but could not find \'loc\' object. branch in file '${absolutePath}' at '${JSON.stringify(position)}'`;
                this.logger.error(message);
                this.conversionErrors.push(message);
            }
            else {
                this.logger.debug('Using branch position from \'locations\' object due to \'SL_useIstanbul\' set to \'true\'');
            }
            return position;
        }
        const newInstrumentation = (parentPosition.line != position.line) || (parentPosition.column != position.column);
        if (hit.branchData.type === 'if') {
            const message = newInstrumentation ? 'Instrumented done by istanbul-lib-instrumenter greater or equal than 5.1.0 enforcing parent positions for the else leave' :
                'Instrumented done by istanbul-lib-instrumenter lower than 5.1.0 using parent positions for the else leave';
            this.logger.debug(message);
            return parentPosition;
        }
        return position;
    }
    createBranchIds(hitFunctions, relativePath, absolutePath) {
        const branchIds = [];
        hitFunctions.forEach(hit => {
            hit.hitLeaves.forEach(leaveIdx => {
                branchIds.push(this.getBranchUniqueId(this.getLeaveStartLoc(hit, leaveIdx, absolutePath), relativePath, absolutePath, leaveIdx));
            });
        });
        return branchIds;
    }
    getMethodUniqueId(startLoc, relativePath, absolutePath, uniqueIdKeysFromFile) {
        const idParts = this.resolveIdParts(startLoc, relativePath, absolutePath);
        // If we have uniqueIdKeysFromFile attempt to map to the correct uniqueId and project root
        if (uniqueIdKeysFromFile === null || uniqueIdKeysFromFile === void 0 ? void 0 : uniqueIdKeysFromFile.length) {
            const matchingKey = this.findCorrectUniqueIdKey(idParts.relativePath, uniqueIdKeysFromFile);
            if (matchingKey) {
                const uniqueId = `${matchingKey}@${this.formatLoc(idParts.start)}`;
                this.logger.debug(`Found matching uniqueId key ${matchingKey} for file ${idParts.relativePath}, returning ${uniqueId} as final uniqueId for footprints`);
                return uniqueId;
            }
        }
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            const uniqueIdKey = idParts.relativePath + '@' + this.formatLoc(idParts.start);
            const uniqueId = (0, new_id_resolver_1.resolveNewId)(uniqueIdKey, idParts.absolutePath, idParts.relativePath, hits_collector_1.HitsCollector.resolveGlobalCoverageObject(), this.logger);
            if (uniqueId) {
                // Remove starting slash if the flag was enabled
                return this.omitFootprintsLeadingSlash ? this.removeLeadingSlashes(uniqueId) : uniqueId;
            }
        }
        return this.buildMethodUniqueId(idParts);
    }
    findCorrectUniqueIdKey(path, uniqueIdKeys) {
        if (!path || !(uniqueIdKeys === null || uniqueIdKeys === void 0 ? void 0 : uniqueIdKeys.length)) {
            return undefined;
        }
        const matchingKeys = [];
        // Find the key that matches the end of the path
        for (const key of uniqueIdKeys) {
            if (!key) {
                continue;
            }
            // Check for exact match
            if (key === path) {
                return key;
            }
            // Check if the key is a suffix of the path
            if (path.endsWith(key)) {
                matchingKeys.push(key);
            }
            // Check the opposite
            if (key.endsWith(path)) {
                matchingKeys.push(key);
            }
        }
        // If there is only one matching key, return it
        if (matchingKeys.length === 1) {
            return matchingKeys[0];
        }
        // If there are multiple matching keys, return the longest one
        return matchingKeys.sort((a, b) => b.length - a.length)[0];
    }
    getBranchUniqueId(startLoc, relativePath, absolutePath, leaveIndex) {
        let uniqueId;
        const parts = this.resolveIdParts(startLoc, relativePath, absolutePath);
        if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
            const uniqueIdKey = parts.relativePath + '|' + this.formatLoc(parts.start) + '|' + leaveIndex;
            uniqueId = (0, new_id_resolver_1.resolveNewId)(uniqueIdKey, parts.absolutePath, parts.relativePath, hits_collector_1.HitsCollector.resolveGlobalCoverageObject(), this.logger);
        }
        if (!uniqueId) {
            uniqueId = parts.relativePath + HitsConverter.BRANCH_ID_DEL + this.formatLoc(parts.start) + HitsConverter.BRANCH_ID_DEL + leaveIndex;
        }
        return uniqueId;
    }
    resolveIdParts(startLoc, relativePath, absolutePath) {
        const sourcePosition = this.sourceMapData.getSourcePosition(relativePath, absolutePath, startLoc, this.projectRoot, this.slMapping);
        return sourcePosition ? sourcePosition : { relativePath: relativePath, start: startLoc, absolutePath: absolutePath };
    }
    buildMethodUniqueId(parts) {
        const path = parts.relativePath + HitsConverter.METHOD_ID_DEL + this.formatLoc(parts.start);
        // Remove starting slash if the flag was enabled
        return this.omitFootprintsLeadingSlash ? this.removeLeadingSlashes(path) : path;
    }
    removeLeadingSlashes(path) {
        // Use a regular expression to remove leading forward and backslashes
        const updatedPath = path.replace(/^[/\\]+/, '');
        return updatedPath;
    }
    sendConversionErrors() {
        if (this.conversionErrors.length > 0) {
            cockpit_notifier_1.CockpitNotifier.sendErrorsBatch(this.conversionErrors);
            this.conversionErrors = [];
        }
    }
    formatLoc(loc) {
        return loc.line + ',' + loc.column;
    }
}
exports.HitsConverter = HitsConverter;
HitsConverter.METHOD_ID_DEL = '@';
HitsConverter.BRANCH_ID_DEL = '|';
//# sourceMappingURL=hits-converter.js.map