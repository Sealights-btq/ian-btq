"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodIdByPositionResolver = void 0;
/**
 * It resolves method ID based on the provided positions.
 * The methods are parsed to get their ranges (from start position to end position) and the resolved method
 * is the most inner function which wraps provided position.
 * @see https://sealights.atlassian.net/wiki/spaces/DEV/pages/4291362821/Difficulties+with+method+location+resolution+on+minified+code
 */
class MethodIdByPositionResolver {
    constructor(methodIdToRange) {
        this.methodIdToRange = methodIdToRange;
    }
    /**
     * It accepts methods read from the original source file.
     * @param methods
     */
    static fromMethods(methods) {
        const parsedMethods = methods
            .map((method, methodId) => {
            var _a, _b, _c;
            const start = findFirstPosition((_b = (_a = method.srcData) === null || _a === void 0 ? void 0 : _a.possiblePos) !== null && _b !== void 0 ? _b : []);
            if (start === null) {
                return false;
            }
            const end = (_c = method.srcData) === null || _c === void 0 ? void 0 : _c.endPosition;
            if (!end) {
                return false;
            }
            return [methodId, { start, end }];
        })
            .filter((x) => !!x)
            // order by start ASC, end DESC
            .sort(([_, a], [_2, b]) => {
            if (isBefore(a.start, b.start)) {
                return -1;
            }
            if (isEqual(a.start, b.start) && isBefore(b.end, a.end)) {
                return -1;
            }
            // there should never be a case where both start and end are equal
            return 1;
        });
        return new this(new Map(parsedMethods));
    }
    /**
     * It accepts position read from the sourcemap of the transpiled source file.
     * It returns index of the method passed to `MethodIdByPositionResolver.parseMethods` which wraps this position.
     * For nested functions, the most inner function is returned.
     * @param position
     */
    resolveMethodId(position) {
        // this is linear search, can be optimized with binary search
        let result = -1;
        for (const [methodId, { start, end }] of this.methodIdToRange.entries()) {
            if (isBefore(position, start)) {
                break;
            }
            if (isAfterOrEqual(position, start) && isBeforeOrEqual(position, end)) {
                result = methodId;
            }
        }
        return result;
    }
}
exports.MethodIdByPositionResolver = MethodIdByPositionResolver;
function findFirstPosition(positions) {
    if (positions.length === 0) {
        return null;
    }
    let result = positions[0].position;
    for (const { position } of positions.slice(1)) {
        if (isBefore(position, result)) {
            result = position;
        }
    }
    return result;
}
function isBefore(a, b) {
    return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]);
}
function isBeforeOrEqual(a, b) {
    return a[0] < b[0] || (a[0] === b[0] && a[1] <= b[1]);
}
function isAfterOrEqual(a, b) {
    return a[0] > b[0] || (a[0] === b[0] && a[1] >= b[1]);
}
function isEqual(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
//# sourceMappingURL=method-id-by-position-resolver.js.map