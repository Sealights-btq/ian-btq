"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HitsCollector = void 0;
const sl_env_vars_1 = require("../constants/sl-env-vars");
const original_module_loader_1 = require("../coverage-elements/original-module-loader");
const cockpit_notifier_1 = require("../agent-events/cockpit-notifier");
const tail_file_reader_1 = require("../utils/tail-file-reader");
/**
 * Compare the current element hits to the previous snapshot and returns the diff
 */
const GLOBAL_ISTANBUL_CONTAINER_NAMES = ['__coverage__'];
class HitsCollector {
    constructor(logger, globalCoverageObject, enableLineCoverage = false) {
        this.enableLineCoverage = enableLineCoverage;
        this.projectRootUniqueIdMap = {};
        this.errors = [];
        this.logger = logger;
        this._globalCoverageObject = globalCoverageObject;
        this.latestCoverageSnapshot = {};
    }
    getHitElements() {
        return __awaiter(this, void 0, void 0, function* () {
            const hitFilesData = [];
            const globalCoverage = this.getGlobalCoverageObject();
            if (sl_env_vars_1.SlEnvVars.isUseNewUniqueId()) {
                new original_module_loader_1.OriginalModuleLoader(globalCoverage, this.logger).load();
            }
            for (const filename in globalCoverage) {
                const { fileCoverageSnapshot, currentFileCoverage, shouldResolveRelativePath } = this.getFileCoverageObjects(filename);
                const hitMethods = this.getHitMethods(currentFileCoverage, fileCoverageSnapshot);
                const hitBranches = this.getHitBranches(currentFileCoverage, fileCoverageSnapshot);
                const hitStatements = this.enableLineCoverage ? this.getHitStatements(currentFileCoverage, fileCoverageSnapshot) : [];
                if (hitMethods.length || hitBranches.length || hitStatements.length) {
                    hitFilesData.push(Object.assign({ filename, hitMethods, hitBranches, shouldResolveRelativePath }, (this.enableLineCoverage && { hitStatements })));
                }
            }
            this.updateCoverageSnapshot(globalCoverage);
            // All async functions must be done before using getHitMethods/getHitBranches or there might be a misalignment when reaching updateCoverageSnapshot
            // getHitMethods/getHitBranches are based on a global element which might be modified from the AUT when the event-loop in browser/nodejs is released
            for (let i = 0; i < hitFilesData.length; i++) {
                const filename = hitFilesData[i].filename;
                yield this.extractUniqueIdsFromFileOnce(filename);
                hitFilesData[i] = Object.assign(Object.assign({}, hitFilesData[i]), { uniqueIdKeysFromFile: this.projectRootUniqueIdMap[filename] });
            }
            // end of async functions
            return hitFilesData;
        });
    }
    extractUniqueIdsFromFileOnce(filename) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.projectRootUniqueIdMap[filename]) {
                return;
            }
            try {
                const lastLine = yield tail_file_reader_1.tailFileReader.read(filename, 1); // Read the last line
                const uniqueIdKeys = lastLine.match(/SL_UNIQUE_ID_KEYS:\s*(.+)$/);
                if (uniqueIdKeys) {
                    this.projectRootUniqueIdMap[filename] = uniqueIdKeys[1].split(',');
                }
            }
            catch (error) {
                this.logger.warn(`Failed to read file ${filename} for unique id extraction: ${error}. Coverage collection might be affected.`);
            }
        });
    }
    get latestCoverageSnapshot() {
        return this._latestCoverageSnapshot;
    }
    set latestCoverageSnapshot(value) {
        this._latestCoverageSnapshot = value;
    }
    get globalCoverageObject() {
        return this._globalCoverageObject;
    }
    set globalCoverageObject(value) {
        this._globalCoverageObject = value;
    }
    setEnableLineCoverage(enableLineCoverage) {
        this.enableLineCoverage = enableLineCoverage;
    }
    getHitStatements(currentHits, snapshotHits) {
        const hitStatementsIndices = Object.keys(currentHits.s).filter(id => {
            snapshotHits.s[id] = snapshotHits.s[id] || 0;
            return currentHits.s[id] > snapshotHits.s[id];
        });
        return hitStatementsIndices.map(id => currentHits.statementMap[id]);
    }
    getHitMethods(currentHits, snapshotHits) {
        const hitMethodsIndices = Object.keys(currentHits.f).filter(id => {
            snapshotHits.f[id] = snapshotHits.f[id] || 0;
            return currentHits.f[id] > snapshotHits.f[id];
        });
        return hitMethodsIndices.map(id => currentHits.fnMap[id]);
    }
    dropHits() {
        this.updateCoverageSnapshot(this.getGlobalCoverageObject());
    }
    getHitLeaves(currentLeaveHits, snapshotLeaveHits) {
        const hitLeavesIndices = [];
        snapshotLeaveHits = snapshotLeaveHits || Array(currentLeaveHits.length).fill(0);
        currentLeaveHits.forEach((leaveHit, leaveIdx) => {
            if (currentLeaveHits[leaveIdx] > snapshotLeaveHits[leaveIdx]) {
                hitLeavesIndices.push(leaveIdx);
            }
        });
        return hitLeavesIndices;
    }
    getHitBranches(currentHits, fileHitSnapshot) {
        const hitBranches = [];
        for (const branchIdx in currentHits.b) {
            const hitLeaves = this.getHitLeaves(currentHits.b[branchIdx], fileHitSnapshot.b[branchIdx]);
            if (hitLeaves.length > 0) {
                const branchData = currentHits.branchMap[branchIdx];
                hitBranches.push({ branchData, hitLeaves });
            }
        }
        return hitBranches;
    }
    createEmptyIstanbulModule(path, useDataKey = false) {
        const emptyModule = {
            f: {},
            fnMap: {},
            b: {},
            branchMap: {},
            path,
            s: {}
        };
        if (useDataKey) {
            return { data: emptyModule };
        }
        return emptyModule;
    }
    getFileCoverageObjects(filename) {
        let fileCoverageSnapshot = this._latestCoverageSnapshot[filename] || this.createEmptyIstanbulModule(filename);
        let currentFileCoverage = this._globalCoverageObject[filename];
        let shouldResolveRelativePath = true;
        // Istanbul may holds the coverage data under 'data' key see (https://sealights.atlassian.net/browse/SLDEV-4421)
        if (!fileCoverageSnapshot.f && fileCoverageSnapshot.data) {
            fileCoverageSnapshot = fileCoverageSnapshot.data;
            shouldResolveRelativePath = false;
        }
        if (!currentFileCoverage.f && currentFileCoverage.data) {
            currentFileCoverage = currentFileCoverage.data;
        }
        return { fileCoverageSnapshot, currentFileCoverage, shouldResolveRelativePath };
    }
    getGlobalCoverageObject() {
        if (this._globalCoverageObject)
            return this._globalCoverageObject;
        this._globalCoverageObject = HitsCollector.resolveGlobalCoverageObject();
        if (!this._globalCoverageObject) {
            this.logger.warn('Coverage object not found');
        }
        return this._globalCoverageObject;
    }
    static resolveGlobalCoverageObject() {
        const re = /^\$\$cov_[0-9]+\$\$$/;
        //const global = new Function('return this')();
        const keys = Object.keys(global);
        for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            if ((re.exec(k)) !== null || GLOBAL_ISTANBUL_CONTAINER_NAMES.indexOf(k) >= 0) {
                return global[k];
            }
        }
    }
    updateCoverageSnapshot(currentCounters) {
        for (const istanbulModule in currentCounters) {
            const useDataKey = currentCounters[istanbulModule].data !== undefined;
            this._latestCoverageSnapshot[istanbulModule] = this._latestCoverageSnapshot[istanbulModule] || this.createEmptyIstanbulModule(istanbulModule, useDataKey);
            const f = currentCounters[istanbulModule].f || currentCounters[istanbulModule].data.f;
            const b = currentCounters[istanbulModule].b || currentCounters[istanbulModule].data.b;
            for (const funcId in f) {
                this.setFunctionHit(istanbulModule, funcId, f, useDataKey);
            }
            for (const branchId in b) {
                this.setBranchHit(b, branchId, istanbulModule, useDataKey);
            }
        }
    }
    setBranchHit(b, branchId, istanbulModule, useDataKey) {
        const currentBranchesHits = b[branchId];
        this._latestCoverageSnapshot[istanbulModule].b[branchId] = this._latestCoverageSnapshot[istanbulModule].b[branchId] || [];
        for (let i = 0; i < currentBranchesHits.length; i++) {
            if (useDataKey) {
                this._latestCoverageSnapshot[istanbulModule].data.b[branchId][i] = currentBranchesHits[i];
            }
            else {
                this._latestCoverageSnapshot[istanbulModule].b[branchId][i] = currentBranchesHits[i];
            }
        }
    }
    setFunctionHit(istanbulModule, funcId, f, useDataKey) {
        if (useDataKey) {
            this._latestCoverageSnapshot[istanbulModule].data.f[funcId] = f[funcId];
        }
        else {
            this._latestCoverageSnapshot[istanbulModule].f[funcId] = f[funcId];
        }
    }
    sendErrors() {
        if (this.errors.length > 0) {
            const data = JSON.stringify(this.errors);
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage(`Errors during hit collection: ${data}`);
            this.errors = [];
        }
    }
}
exports.HitsCollector = HitsCollector;
//# sourceMappingURL=hits-collector.js.map