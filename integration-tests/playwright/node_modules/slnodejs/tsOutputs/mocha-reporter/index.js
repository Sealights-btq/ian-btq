var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable @typescript-eslint/no-var-requires */
const mocha = require('mocha');
const Base = mocha.reporters.Base;
const utils = mocha.utils;
const inherits = utils.inherits;
let logger;
const sealights = require('../test-listener/api');
const ConfigLoader = require('../common/config-process/config-loader').ConfigLoader;
const Constants = require('./constants');
const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');
const { CockpitNotifier } = require('../common/agent-events/cockpit-notifier');
const { MockInspector } = require('../common/mock-inspector');
const { SlEnvVars } = require('../common/constants/sl-env-vars');
const { OtelAgent } = require('./otel-agent');
function log(msg) {
    let args = Array.prototype.slice.apply(arguments);
    if (logger) {
        logger.info.apply(logger, args);
    }
    else {
        args[0] = '[SeaLights for Mocha] ' + args[0];
        console.log.apply(console, args);
    }
}
function warn(msg) {
    let args = Array.prototype.slice.apply(arguments);
    if (logger) {
        logger.warn.apply(logger, args);
    }
    else {
        args[0] = '[SeaLights for Mocha] ' + args[0];
        console.warn.apply(console, args);
    }
}
function error(msg) {
    let args = Array.prototype.slice.apply(arguments);
    if (logger) {
        logger.error.apply(logger, args);
    }
    else {
        args[0] = '[SeaLights for Mocha] ' + args[0];
        console.error.apply(console, args);
    }
}
/**
 * Expose `SeaLightsReporter`.
 */
exports = module.exports = SeaLightsReporter;
/**
 * Initialize a new `SeaLightsReporter` reporter.
 *
 * @param {Runner} runner
 * @api public
 */
function SeaLightsReporter(runner, options) {
    var _a;
    // Use for silent running during tests (Summary of test result not printed)
    if (options && options.reporterOptions && options.reporterOptions.skipEpilogue) {
        Base.prototype.epilogue = function () {
        };
    }
    Base.call(this, runner, options);
    let otelAgent;
    let reporter = this;
    let slProcess = null;
    let executionId = null;
    let shutDownTimeout = 60 * 1000; //Allow 1 minute to send all remaining footprints and events
    let counters = {
        start: 0,
        fail: 0,
        pass: 0,
        end: 0,
        skipped: 0
    };
    let warnedOnce = false;
    let reporterName = (options && options.reporterOptions && options.reporterOptions.reporter) || 'spec';
    let mochaReporters = mocha.reporters;
    let ChainedReporterType = mochaReporters.spec;
    let afterAllCalled = false;
    let mockInspector = new MockInspector({ warn });
    let inspectedFiles = {};
    let reportSuites = ((_a = options === null || options === void 0 ? void 0 : options.reporterOptions) === null || _a === void 0 ? void 0 : _a.reportSuites) === 'true';
    const suiteStarted = {};
    const suiteStatusFailedOnce = {};
    const suiteStatusPassedOnce = {};
    if (mochaReporters.hasOwnProperty(reporterName)) {
        ChainedReporterType = mochaReporters[reporterName];
    }
    else {
        try {
            ChainedReporterType = require(reporterName);
        }
        catch (e) {
            warn('Cannot find reporter ' + reporterName + ', using default Spec reporter');
            //ChainedReporterType = mochaReporters.spec; //default
        }
    }
    new ChainedReporterType(runner, options);
    runner.suite.beforeEach(function (done) {
        if (!slProcess)
            return;
        // Inspect test body for mocks of internal Node modules and global objects
        try {
            const testFile = this.currentTest.file;
            // Check if test file exists and hasn't been inspected yet
            if ((testFile === null || testFile === void 0 ? void 0 : testFile.length) && !inspectedFiles[testFile]) {
                const testFileBody = fs.readFileSync(testFile, 'utf8');
                mockInspector.inspectTestBody(testFileBody);
                inspectedFiles[testFile] = true;
            }
        }
        catch (e) {
            const errorMessage = `Error inspecting test file ${this.currentTest.file} for possible mocks of internal/global Node modules. ${e.message}`;
            error(errorMessage, error);
            CockpitNotifier.sendError(errorMessage);
        }
        otelAgent.handleBeforeEach({
            testData: { executionId },
            context: this,
            done
        });
    });
    runner.suite.afterEach(function (done) {
        if (!slProcess)
            return;
        otelAgent.handleAfterEach({
            testData: { executionId },
            context: this,
            done
        });
    });
    // Before running any suite, initialize SL and create a test execution ID
    runner.suite.beforeAll(function () {
        return __awaiter(this, void 0, void 0, function* () {
            log('Version ' + reporter.getVersion() + ', agent version ' + sealights.getVersion());
            log('Initializing');
            this.timeout((Constants.TIA_TIMEOUT + 10) * 1000); // TIA polling timeout is 60 seconds plus an extra 10 seconds
            let timeoutReached = false;
            let timer;
            const timeoutPromise = new Promise((resolve) => {
                timer = setTimeout(() => {
                    timeoutReached = true;
                    error('****** Timeout reached in beforeAll hook - skipping TIA logic ******');
                    resolve(); // Complete the Promise, even if it times out
                }, Constants.TIA_TIMEOUT * 1000); // Same value as the timeout above
            });
            const failurePromise = new Promise((resolve) => {
                runner.on('fail', (test, err) => {
                    error(err.message);
                    // Check if the failure is due to a timeout
                    if (err.message.startsWith('Timeout')) {
                        error(`****** Test "${test.title}" timed out. ******`);
                        resolve(); // Complete the Promise, even if it times out
                    }
                });
            });
            // Use Promise.race to resolve with the first settled promise (either timeoutPromise, failurePromise, or initPromise)
            yield Promise.race([timeoutPromise, failurePromise, initTestListener(reportSuites)]);
            if (!timeoutReached) {
                timeoutReached = true;
                clearTimeout(timer); // Clear the timer
            }
        });
    });
    // After all tests have been executed, wait for the SL process to shut down
    runner.suite.afterAll(function (done) {
        afterAllCalled = true;
        if (!slProcess)
            return done();
        otelAgent.handleAfterAll({
            testData: { executionId },
            context: this
        });
        pushExecutionEndEvent();
        slProcess.resume && slProcess.resume();
        executionId = null;
        let doneCallbackInvoked = false;
        function invokeDoneCallback(err) {
            if (doneCallbackInvoked)
                return;
            if (handle) {
                try {
                    clearTimeout(handle); //Don't keep the process running because of this timeout
                    handle = null;
                }
                catch (e) {
                    error(e);
                }
            }
            doneCallbackInvoked = true;
            if (done) {
                done(err);
            }
        }
        let handle = setTimeout(function () {
            if (doneCallbackInvoked)
                return; //callback already called
            handle = null;
            warn('Send operation timed out.');
            invokeDoneCallback();
        }, shutDownTimeout);
        this.timeout(0); //Disable mocha's timeout, since we handle the timeout here^^.
        try {
            log('Sending remaining data to server');
            slProcess.stop(invokeDoneCallback);
        }
        catch (err) {
            error('Error send remaining data to the server', err);
            invokeDoneCallback();
        }
    });
    runner.on('hook fail', function (hook, err) {
        if (hook.title.startsWith('before all')) {
            console.log('Before all hook failed: ' + hook.title + ' - error: ' + err.message);
        }
        else if (hook.title.startsWith('after all')) {
            console.log('After all hook failed: ' + hook.title + ' - error: ' + err.message);
        }
    });
    if (reportSuites) {
        runner.on(Constants.MOCHA.EVENT_SUITE_BEGIN, function (suite) {
            var _a;
            if (((_a = suite.tests) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                return;
            }
            suiteStarted[suite.fullTitle()] = true;
            handleTestBeginEvent(suite);
        });
        runner.on(Constants.MOCHA.EVENT_TEST_FAIL, function (testOrHook, err) {
            var _a;
            if (checkForNoneSupportedTests(testOrHook)) {
                return;
            }
            try {
                let suiteName = (_a = test.parent) === null || _a === void 0 ? void 0 : _a.fullTitle();
                suiteStatusFailedOnce[suiteName] = true;
                if (testOrHook.type === Constants.MOCHA.TYPE_HOOK) {
                    error('Hook failed: ' + testOrHook.title + ' - error: ' + err.message);
                }
            }
            catch (e) {
                error('error in fail event handler: ' + e);
            }
        });
        runner.on(Constants.MOCHA.EVENT_TEST_PASS, function (test, err) {
            var _a;
            let suiteName = (_a = test.parent) === null || _a === void 0 ? void 0 : _a.fullTitle();
            suiteStatusPassedOnce[suiteName] = true;
        });
        runner.on(Constants.MOCHA.EVENT_SUITE_END, function (suite) {
            let suiteName = suite.fullTitle();
            if (suiteStatusFailedOnce[suiteName]) {
                counters.fail++;
                counters.end++;
                if (slProcess)
                    pushEndTestEvent(suite, Constants.SEALIGHTS.TEST_STATUS.FAILED);
            }
            else if (suiteStatusPassedOnce[suiteName]) {
                counters.pass++;
                counters.end++;
                if (slProcess)
                    pushEndTestEvent(suite, Constants.SEALIGHTS.TEST_STATUS.PASSED);
            }
            else if (suiteStarted[suiteName]) {
                counters.skipped++;
                counters.end++;
                if (slProcess)
                    processSkipSuite(suite, true);
            }
            handleAfterTestEndReported();
        });
    }
    else {
        runner.on(Constants.MOCHA.EVENT_TEST_BEGIN, function (test) {
            handleTestBeginEvent(test);
        });
        runner.on(Constants.MOCHA.EVENT_TEST_FAIL, function (testOrHook, err) {
            if (checkForNoneSupportedTests(testOrHook)) {
                return;
            }
            try {
                if (!slProcess) {
                    return;
                }
                if (testOrHook.type === Constants.MOCHA.TYPE_HOOK) {
                    error('Hook failed: ' + testOrHook.title + ' - error: ' + err.message);
                    testOrHook.duration = 0; // Set duration to 0 for hooks so they are not considered for TIA
                    counters.start++;
                    pushStartTestEvent(testOrHook);
                }
                counters.fail++;
                pushEndTestEvent(testOrHook, Constants.SEALIGHTS.TEST_STATUS.FAILED);
            }
            catch (e) {
                error('error in fail event handler: ' + e);
            }
        });
        runner.on(Constants.MOCHA.EVENT_TEST_PASS, function (test, err) {
            counters.pass++;
            if (err)
                error('pass error: ' + err + '\n' + err.stack);
            try {
                if (!slProcess)
                    return;
                pushEndTestEvent(test, Constants.SEALIGHTS.TEST_STATUS.PASSED);
            }
            catch (e) {
                error('error in test pass event handler: ' + e);
            }
        });
        runner.on(Constants.MOCHA.EVENT_TEST_END, function (test) {
            counters.end++;
            handleAfterTestEndReported();
        });
        runner.on(Constants.MOCHA.EVENT_TEST_PENDING, function (test) {
            counters.skipped++;
            processSkipTest(test);
        });
    }
    function handleTestBeginEvent(testOrSuite) {
        counters.start++;
        try {
            if (!slProcess && !warnedOnce) {
                warn('Mocha reporter was not properly intiailized.');
                warnedOnce = true;
                return;
            }
            pushStartTestEvent(testOrSuite);
        }
        catch (e) {
            error('error in test event handler: ' + e);
        }
    }
    function checkForNoneSupportedTests(testOrHook) {
        return (testOrHook.type !== Constants.MOCHA.TYPE_TEST && testOrHook.type !== Constants.MOCHA.TYPE_HOOK);
    }
    function handleAfterTestEndReported() {
        try {
            if (!slProcess)
                return;
            slProcess.setCurrentTestIdentifier(null);
        }
        catch (e) {
            error('error in test end event handler: ' + e);
        }
    }
    ;
    function processSkipSuite(suite) {
        processSkipTestEvent(suite);
    }
    function processSkipTest(test) {
        processSkipTestEvent(test);
    }
    function processSkipTestEvent(testOrSuite, reportSuites) {
        try {
            if (!slProcess)
                return;
            pushStartTestEvent(testOrSuite);
            pushEndTestEvent(testOrSuite, Constants.SEALIGHTS.TEST_STATUS.SKIPPED);
        }
        catch (e) {
            error('error in pending test event handler: ' + e);
        }
    }
    function getSuitePath(t) {
        let parts = [];
        while (t) {
            if (t.parent)
                parts.unshift(t.title);
            t = t.parent;
        }
        return parts;
    }
    function clone(o) {
        return JSON.parse(JSON.stringify(o));
    }
    this.getExecutionId = function getExecutionId() {
        return executionId;
    };
    this.getVersion = function getVersion() {
        return process.env.npm_package_version;
    };
    function initTestListener(reportSuites) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const toolInfo = {
                    name: 'mocha',
                    version: mocha.prototype.version
                };
                let agentConfig = new ConfigLoader().loadAgentConfiguration();
                agentConfig.shouldCheckForActiveExecutionOnStartUp.value = false;
                slProcess = yield sealights.initAsync(agentConfig, toolInfo);
                logger = slProcess.getLogger('SeaLights for Mocha');
                otelAgent = new OtelAgent({ agentConfig, logger });
                log('Initialized');
                yield pushExecutionStartedEvent();
                let __initTestId = slProcess.createTestId(executionId, '__init');
                slProcess.setCurrentTestIdentifier(__initTestId, true);
                const excludedTestsMap = yield slProcess.testRecommendationHandler.getExcludedTests();
                processTests(runner.suite, excludedTestsMap, reportSuites);
            }
            catch (err) {
                error('Initialization error', err);
            }
        });
    }
    function pushExecutionStartedEvent() {
        executionId = slProcess.createTestSuiteId();
        return slProcess.startColoredExecution(executionId);
    }
    function pushExecutionEndEvent() {
        slProcess.pushEvent({
            type: Constants.SEALIGHTS.EVENT_TYPES.EXECUTION.END,
            executionId: executionId,
            meta: {
                counters: clone(counters)
            }
        });
    }
    function pushStartTestEvent(test) {
        let testName = test.fullTitle();
        let testId = slProcess.createTestId(executionId, testName);
        slProcess.setCurrentTestIdentifier(testId);
        pushTestEvent(test, Constants.SEALIGHTS.EVENT_TYPES.TESTS.START);
    }
    function pushEndTestEvent(test, testStatus) {
        pushTestEvent(test, Constants.SEALIGHTS.EVENT_TYPES.TESTS.END, testStatus);
    }
    function pushTestEvent(test, eventType, testStatus) {
        let testName = test.fullTitle();
        let suitePath = getSuitePath(test);
        let event = {
            type: eventType,
            testName,
            executionId,
            testPath: suitePath,
            meta: {
                counters: clone(counters)
            }
        };
        // Mark test as dummy
        if (testName === 'SLEmptyTest') {
            event.testType = 'dummy';
        }
        if (eventType === Constants.SEALIGHTS.EVENT_TYPES.TESTS.END) {
            event.result = testStatus;
            event.duration = test.duration;
        }
        slProcess.pushEvent(event);
    }
    function processTests(suite, excludedTestsMap, reportSuites) {
        let childHasBeforeHook = false; // Child suite has beforeAll hook
        let allTestsSkip = true; // There are no tests or all the tests are skipped
        let hasBeforeEachHook = false; // Current suite has beforeEach hook
        if (suite.suites && suite.suites.length) {
            suite.suites.forEach(function (currSuite) {
                if (currSuite._beforeAll.length)
                    childHasBeforeHook = true;
                processTests(currSuite, excludedTestsMap, reportSuites);
            });
        }
        if (suite.tests && suite.tests.length) {
            suite.tests.forEach(function (tst) {
                var _a;
                const shouldBeSkipped = reportSuites ? excludedTestsMap[(_a = tst.parent) === null || _a === void 0 ? void 0 : _a.fullTitle()] : excludedTestsMap[tst.fullTitle()];
                if (shouldBeSkipped) {
                    log('Test ' + tst.fullTitle() + ' skipped');
                    tst.pending = true;
                }
                else if (!tst.pending) {
                    // At least one test exists that is not skipped
                    allTestsSkip = false;
                }
            });
        }
        if (suite._beforeEach.length - 1)
            hasBeforeEachHook = true;
        // Inject dummy test [SLDEV-10234]
        if (childHasBeforeHook && allTestsSkip && hasBeforeEachHook) {
            if (!SlEnvVars.getDisableHookDependencyGuard()) {
                CockpitNotifier.sendWarning('Hook dependency detected in "' + suite.title + '". Dummy test was injected to avoid failure.');
                suite.addTest(new mocha.Test('SLEmptyTest', () => { }));
            }
            else {
                CockpitNotifier.sendWarning('Hook dependency detected in "' + suite.title + '". Test injection is disabled.');
            }
        }
    }
    process.on('exit', function () {
        if (!afterAllCalled) {
            endExecutionSync();
        }
    });
    function endExecutionSync() {
        let scriptPath = path.resolve(__dirname, 'end-execution.js');
        childProcess.spawnSync(process.argv0, [scriptPath, executionId], {
            stdio: [process.stdin, process.stdout, process.stderr],
            encoding: 'utf-8'
        });
    }
}
inherits(SeaLightsReporter, Base);
//# sourceMappingURL=index.js.map