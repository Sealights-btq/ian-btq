"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseExecutor = void 0;
const contracts_1 = require("../contracts");
const token_data_builder_1 = require("../../common/utils/token-data-builder");
const build_session_data_builder_1 = require("../../common/utils/build-session-data-builder");
const contracts_2 = require("../../common/http/contracts");
const agent_instance_data_1 = require("../agent-instance-data");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
const agent_events_contracts_1 = require("../../common/agent-events/agent-events-contracts");
const logger_1 = require("../../common/logger");
const config_loader_1 = require("../../common/config-process/config-loader");
const v8_utils_1 = require("../../common/v8-utils");
const agent_time_synchronizer_1 = require("../agent-time-synchronizer");
const system_date_1 = require("../../common/system-date");
const http_client_1 = require("../../common/http/http-client");
const preloader_1 = require("../preloader");
const sl_env_vars_1 = require("../../common/constants/sl-env-vars");
const backend_proxy_with_default_client_1 = require("../../common/http/backend-proxy-with-default-client");
const backend_proxy_1 = require("../../common/http/backend-proxy");
const fs_1 = require("fs");
/**
 * Base class for executing all CLI commands.
 * Verify that buildSessionId and token params are correct.
 * Also download the node agent if needed.
 */
class BaseExecutor {
    constructor() {
        this.logger = logger_1.LoggerFactory.getCreateApplicationLogger();
    }
    execute(args, extraArgs, dontExit = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.beControlledVersions || sl_env_vars_1.SlEnvVars.isBeControlledVersions()) {
                const tokenData = new token_data_builder_1.TokenDataBuilder().build(args);
                const preloader = new preloader_1.Preloader();
                yield preloader.runWithControlledVersion(tokenData);
                return;
            }
            this.shouldDumpEnvironment();
            this.shouldInstrumentGlobalObject();
            this.printCommandWithAgentId();
            this.extraArgs = extraArgs;
            const agentInstanceData = agent_instance_data_1.AgentInstanceDataFactory.getOrCreateAgentInstanceData();
            let result = true;
            try {
                result = this.validateArgs(args);
                if (result) {
                    yield this.resolveBaseData(args);
                    yield this.getRemoteConfigFromServer(this._baseData);
                    const { timeClock } = this.agentRemoteConfig;
                    if (timeClock === null || timeClock === void 0 ? void 0 : timeClock.enabled) {
                        yield agent_time_synchronizer_1.AgentTimeSynchronizer.getCreateAgentTimeSynchronizer(timeClock === null || timeClock === void 0 ? void 0 : timeClock.syncIntervalSec, this.logger, this._baseData, agentInstanceData).initiateClockSync();
                    }
                    yield this.notifyAgentStarted(agentInstanceData, args);
                    this.notifyConfigurationChanged(this._baseData);
                    result = yield this.innerExecute(args, extraArgs);
                    yield this.notifyAgentShutdown();
                }
            }
            catch (e) {
                this.logger.error(e.message);
                result = false;
            }
            finally {
                if (!dontExit) {
                    this.exitProcess(result, args.failbuild);
                }
            }
        });
    }
    shouldDumpEnvironment() {
        if (!sl_env_vars_1.SlEnvVars.CIA.dumpEnvironment()) {
            return;
        }
        const generateEnvironmentDumpFilePath = () => {
            return process.cwd() + `/sl-env-vars-${(0, system_date_1.getSystemDate)().toISOString().replace(/:/g, '-').replace(/\./g, '-')}.json`;
        };
        const dumpEnvironment = () => {
            try {
                const envVars = process.env;
                (0, fs_1.writeFileSync)(generateEnvironmentDumpFilePath(), JSON.stringify(envVars, null, 2));
            }
            catch (e) {
                this.logger.error(`Failed to write environment variables to file: env-vars.json. Error: ${e}`);
            }
        };
        this.logger.info(`Environment variables dump was activated. Environment dump is periodic process that will be executed each minute, and will be written to sl-env-vars-{timestamp}.json file suffix with the current date and time.
        Be mindful when sharing said files, make sure to obfuscate any sensitive information before.`);
        dumpEnvironment();
        setInterval(() => {
            dumpEnvironment();
        }, 60 * 1000);
    }
    shouldInstrumentGlobalObject() {
        if (sl_env_vars_1.SlEnvVars.CIA.instrumentGlobal()) {
            this.logger.info(`Global object instrumentation was activated. All changes to the global object will be tracked and exported to sl-global-object-export.json file.
            Be mindful when sharing this file, make sure to obfuscate any sensitive information before.`);
            // This only instruments the global object of the Agent (current process)
            Promise.resolve().then(() => require('../../test-listener/instrument-global'));
        }
    }
    printCommandWithAgentId() {
        this.logger.info(`Starting sealights agent with command '${this.commandName}',  agentId: ${agent_instance_data_1.AgentInstanceDataFactory.getOrCreateAgentInstanceData().agentId}`);
    }
    printAgentVersionAndAgentId() {
        const agentInstanceData = agent_instance_data_1.AgentInstanceDataFactory.getOrCreateAgentInstanceData();
        this.logger.lifecycle(`slnodejs agent version: ${agentInstanceData.agentVersion},  agentId: ${agentInstanceData.agentId}`);
    }
    resolveBaseData(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenData = new token_data_builder_1.TokenDataBuilder().build(args);
            if (!tokenData.isValid) {
                throw new Error('Invalid token. Skipping sealights integration. See log for more details');
            }
            const httpConfig = Object.assign(Object.assign(Object.assign({}, this.getBackendProxyConfig(args)), tokenData), { proxy: args.proxy });
            this.backendProxy = backend_proxy_with_default_client_1.BackendProxyFactory.initWithDefaultClient(agent_instance_data_1.AgentInstanceDataFactory.getOrCreateAgentInstanceData(), httpConfig, this.logger);
            const buildSessionData = yield this.getBuildSessionData(args);
            if (!buildSessionData) {
                throw new Error('Invalid build session data. Skipping sealights integration. See log for more details');
            }
            this.backendProxy.updateMetadata({
                buildSessionId: buildSessionData.buildSessionId
            });
            this._baseData = Object.assign(Object.assign(Object.assign({}, tokenData), buildSessionData), { proxy: args.proxy, labid: args.labid });
        });
    }
    /**
     * Use to pass additional configuration of BackendProxy.
     * Data from token and proxy from CLI arguments take precedence over data returned by this method.
     * @param _args
     * @protected
     */
    getBackendProxyConfig(_args) {
        return {};
    }
    exitProcess(result, failbuild) {
        result ? this.logSuccess() : this.logError('Additional data may be found by turning on logs via the NODE_DEBUG=sl environment variable');
        let statusCode = 0;
        const shouldFail = !result && failbuild;
        if (shouldFail) {
            statusCode = failbuild ? 1 : 0;
        }
        process.exit(statusCode);
    }
    /**
     * If some command needs to do some validation before downloading the agent, this method can be overridden.
     * @default true
     * @param args
     */
    validateArgs(args) {
        return true;
    }
    set baseData(value) {
        this._baseData = value;
    }
    get baseData() {
        return this._baseData;
    }
    getBuildSessionData(cmd) {
        return __awaiter(this, void 0, void 0, function* () {
            const buildSessionDataBuilder = new build_session_data_builder_1.BuildSessionDataBuilder(this.backendProxy);
            return yield buildSessionDataBuilder.build(cmd);
        });
    }
    getInstrumentationMethodology() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { methodology } = yield this.backendProxy.getInstrumentationMethodology(this._baseData.buildSessionId);
                return methodology;
            }
            catch (e) {
                const errorMsg = `Failed to get instrumentation methodology, defaulting to Methods instrumentation methodology. Error: '${e}'`;
                this.logger.error(errorMsg);
                cockpit_notifier_1.CockpitNotifier.sendError(errorMsg);
                return contracts_2.InstrumentationMethodology.Methods;
            }
        });
    }
    logSuccess() {
        this.logger.lifecycle(`Command '${this.commandName}' finished successfully`);
    }
    logError(err) {
        this.logger.lifecycle(`Failed to run command '${this.commandName}'! ${err || ''}`);
        if (typeof err === 'string') {
            cockpit_notifier_1.CockpitNotifier.sendError(err);
        }
        else if (err === null || err === void 0 ? void 0 : err.message) {
            cockpit_notifier_1.CockpitNotifier.sendError(err.message);
        }
    }
    notifyAgentStarted(agentInstanceData, cmdArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            agentInstanceData.AgentAllocatedMemoryInMb = yield v8_utils_1.V8Utils.heapSizeLimitMB();
            // labId should not be passed to notifyStart as it tricks the backend into thinking there is a live agent
            const agentConfig = this.createAgentConfig(cmdArgs, true);
            try {
                yield cockpit_notifier_1.CockpitNotifier.notifyStart(agentConfig, agentInstanceData, this.logger, system_date_1.getSystemOffset, this.backendProxy);
            }
            catch (e) {
                this.logger.error(`Failed to submit agent start event, Error: '${e}'`);
            }
        });
    }
    createAgentConfig(cmdArgs, omitLabId = false) {
        // We named build, branch and labId differently in base data vs config, this should be properly redesigned with bellow fix
        const cmd = Object.assign(Object.assign({}, this.baseData), { branch: this.baseData.branchName, build: this.baseData.buildName, labId: omitLabId ? undefined : this.baseData.labid });
        if (cmdArgs[contracts_1.COMMAND_ARGS.INSTRUMENT_FOR_BROWSERS]) {
            cmd[contracts_1.COMMAND_ARGS.USE_OTEL] =
                cmdArgs[contracts_1.COMMAND_ARGS.ENABLE_OPEN_TELEMETRY];
        }
        const agentConfig = new config_loader_1.ConfigLoader().loadAgentConfiguration(cmd);
        if (this.agentRemoteConfig) {
            Object.keys(this.agentRemoteConfig).forEach(key => {
                if (agentConfig[key] !== undefined) {
                    agentConfig[key].value = this.agentRemoteConfig[key];
                }
            });
        }
        // TODO: BackendProxy shouldn't be used here directly
        // instead we need to pass config provider into BackendProxy and take value from it
        if (agentConfig.httpAttemptInterval.hasValue) {
            backend_proxy_1.BackendProxy.DEFAULT_HTTP_ATTEMPT_INTERVAL = agentConfig.httpAttemptInterval.value;
        }
        if (agentConfig.httpMaxAttempts.hasValue) {
            backend_proxy_1.BackendProxy.DEFAULT_HTTP_MAX_ATTEMPTS = agentConfig.httpMaxAttempts.value;
        }
        if (agentConfig.httpTimeout.hasValue) {
            http_client_1.HttpClient.DEFAULT_HTTP_TIMEOUT = agentConfig.httpTimeout.value;
        }
        return agentConfig;
    }
    notifyAgentShutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield cockpit_notifier_1.CockpitNotifier.notifyShutdown();
            }
            catch (e) {
                this.logger.error(`Failed to submit agent shutdown event, Error: '${e}'`);
            }
        });
    }
    getRemoteConfigFromServer(agentBaseData) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const remoteConfig = yield this.backendProxy.getRemoteConfigPromise(agentBaseData);
                this.agentRemoteConfig = remoteConfig || {};
            }
            catch (e) {
                this.logger.warn(`Failed to receive remote config, error: '${e}'. Using init config from cmd args and env vars`);
                this.agentRemoteConfig = {};
            }
        });
    }
    notifyConfigurationChanged(cmdArgs) {
        if (Object.keys(this.agentRemoteConfig).length > 0) {
            const agentConfig = new config_loader_1.ConfigLoader().loadAgentConfiguration(cmdArgs);
            const eventData = {
                agentConfig: Object.assign(Object.assign({}, agentConfig.toJsonObject()), this.agentRemoteConfig),
            };
            cockpit_notifier_1.CockpitNotifier.sendEvent(agent_events_contracts_1.AgentEventCode.AGENT_CONFIG_CHANGED, eventData);
        }
    }
}
exports.BaseExecutor = BaseExecutor;
//# sourceMappingURL=base-executor.js.map