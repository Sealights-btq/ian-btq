"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilePathFixer = void 0;
const path_1 = require("path");
const files_utils_1 = require("../../common/utils/files-utils");
const file_element_utils_1 = require("./file-element-utils");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
const validation_utils_1 = require("../../common/utils/validation-utils");
class FilePathFixer {
    constructor(filesContainer, slMapper, nodeV8RawCoverageSlMapper, logger, projectRoot, useModulePrefix, uniqueModuleId, isRawCoverage = false, embedCorrectUniqueId = false) {
        this.filesContainer = filesContainer;
        this.slMapper = slMapper;
        this.nodeV8RawCoverageSlMapper = nodeV8RawCoverageSlMapper;
        this.logger = logger;
        this.isRawCoverage = isRawCoverage;
        this.embedCorrectUniqueId = embedCorrectUniqueId;
        this.prefix = '';
        this.projectRoot = '';
        this.removeAutoGeneratedFiles = false;
        this.embeddedMapping = {};
        validation_utils_1.ValidationUtils.verifyNotNullOrEmptyMultiParams([
            { value: filesContainer, paramName: 'filesContainer' },
            { value: slMapper, paramName: 'slMapper' },
            { value: logger, paramName: 'logger' },
        ]);
        if (useModulePrefix) {
            this.setPrefix(uniqueModuleId);
        }
        this.projectRoot = files_utils_1.FilesUtils.adjustPathSlashes((0, path_1.normalize)(projectRoot));
    }
    setPrefix(uniqueModuleId) {
        if (uniqueModuleId) {
            this.prefix = `${uniqueModuleId}/`;
        }
        if (this.prefix) {
            cockpit_notifier_1.CockpitNotifier.sendGenericMessage(`Using '${this.prefix}' as prefix to files path and uniqueIds, moduleName: '${uniqueModuleId}'`);
        }
    }
    fixFilePathes(files) {
        const duplicatesMatchFiles = [];
        let prefixToAdd = '';
        const uniqueFiles = [...files];
        for (const file of files) {
            const filesFromFileContainer = this.findPathInFilesContainer(file.logicalPath);
            // Handle duplicate files
            if (filesFromFileContainer.length > 1) {
                this.logger.warn(`Found multiple matches for file '${file.logicalPath}': ${filesFromFileContainer.join(', ')}`);
                cockpit_notifier_1.CockpitNotifier.sendWarning(`Multiple source files found with name '${file.logicalPath}' -> ${filesFromFileContainer.join(', ')}. If your source-maps do not contain full file paths, this may cause incorrect mappings. See: https://sealights.atlassian.net/wiki/spaces/KH/pages/4154851332/Issue+Showing+Files+in+Wrong+Locations`);
                duplicatesMatchFiles.push(file);
                continue;
            }
            // perfect case - processing
            if (filesFromFileContainer.length === 1) {
                const fullFilePath = filesFromFileContainer[0];
                prefixToAdd = fullFilePath.replace(file.logicalPath, '');
                this.fixOneFile(file, fullFilePath);
                continue;
            }
            // remove file from build map if flag allow that
            if (this.removeAutoGeneratedFiles) {
                this.logger.info(`Cannot find file ${file.logicalPath} in source files. File is auto generated.`);
                const indexToRemove = uniqueFiles.indexOf(file);
                uniqueFiles.splice(indexToRemove, 1);
                continue;
            }
            // fallback - source file was not found, trying to resolve path only by references from build map
            const fixedPath = file.logicalPath.replace(this.projectRoot, '');
            this.fixOneFile(file, fixedPath);
        }
        // Process duplicate files with a warning about potential incorrect mapping
        if (duplicatesMatchFiles.length > 0) {
            this.logger.warn(`Processing ${duplicatesMatchFiles.length} files with duplicate names. Mappings may be incorrect if source maps don't contain full paths.`);
            for (const fileToFix of duplicatesMatchFiles) {
                this.fixOneFile(fileToFix, `${prefixToAdd}${fileToFix.logicalPath}`);
            }
        }
        if (this.embedCorrectUniqueId) {
            Object.keys(this.embeddedMapping).forEach(filePath => {
                this.slMapper.addEmbeddedMapping(filePath, this.embeddedMapping[filePath]);
            });
        }
        return uniqueFiles;
    }
    addEmbeddedMapping(filePath, mapping) {
        if (this.embeddedMapping[filePath]) {
            this.embeddedMapping[filePath][mapping.sourcePath] = mapping.targetPath;
        }
        else {
            this.embeddedMapping[filePath] = { [mapping.sourcePath]: mapping.targetPath };
        }
    }
    fixOneFile(file, filePath) {
        const fixedFilePath = files_utils_1.FilesUtils.adjustPathSlashes(filePath);
        this.slMapper.addFileMapping(file.logicalPath, fixedFilePath);
        file.logicalPath = this.getLogicalPath(fixedFilePath);
        file.physicalPath = fixedFilePath;
        file.absolutePath = this.getAbsolutePath(fixedFilePath);
        file.methods.forEach(method => {
            method.uniqueId = `${file.logicalPath}@${method.position.join(',')}`;
            if (this.isRawCoverage) {
                const pathToScannedFile = this.getPathFromUniqueIdKey(method.uniqueIdKey);
                method.offsets.forEach(offset => {
                    const offsetId = [pathToScannedFile, offset].join('#');
                    this.nodeV8RawCoverageSlMapper.addUniqueIdMapping(offsetId, method.uniqueId);
                });
            }
            this.slMapper.addUniqueIdMapping(method.uniqueIdKey, method.uniqueId);
            if (this.embedCorrectUniqueId) {
                this.addEmbeddedMapping(file.transpiledFile, { sourcePath: method.uniqueIdKey, targetPath: method.uniqueId });
            }
            delete method.uniqueIdKey;
        });
        // TODO: do that only when --usebranchcoverage provided
        file.branches.forEach(branch => {
            const position = (0, file_element_utils_1.getBranchPosition)(branch);
            branch.uniqueId = `${file.logicalPath}|${position.join(',')}|${branch.index}`;
            this.slMapper.addUniqueIdMapping(branch.uniqueIdKey, branch.uniqueId);
            if (this.embedCorrectUniqueId) {
                this.addEmbeddedMapping(file.transpiledFile, { sourcePath: branch.uniqueIdKey, targetPath: branch.uniqueId });
            }
            delete branch.uniqueIdKey;
        });
    }
    getLogicalPath(fixedPath) {
        let pathWithPrefix = `${this.prefix}${fixedPath}`;
        if (pathWithPrefix.indexOf('/') === 0) {
            pathWithPrefix = pathWithPrefix.substring(1);
        }
        return files_utils_1.FilesUtils.adjustPathSlashes(pathWithPrefix);
    }
    getAbsolutePath(fixedPath) {
        const absolutePath = (0, path_1.join)(this.projectRoot, fixedPath);
        return files_utils_1.FilesUtils.adjustPathSlashes(absolutePath);
    }
    findPathInFilesContainer(sourceFilePath) {
        const files = this.filesContainer.getFilePath(sourceFilePath);
        return files !== null ? files : [];
    }
    getPathFromUniqueIdKey(uniqueIdKey = '') {
        const [absolutePath] = uniqueIdKey.split('@');
        return files_utils_1.FilesUtils.adjustPathSlashes((0, path_1.relative)(this.projectRoot, absolutePath));
    }
}
exports.FilePathFixer = FilePathFixer;
//# sourceMappingURL=file-path-fixer.js.map