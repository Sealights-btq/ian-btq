"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildExecutor = void 0;
const base_executor_1 = require("./base-executor");
const contracts_1 = require("../contracts");
const cia_1 = require("../../build-scanner/cia");
const agent_instance_data_1 = require("../../common/agent-instance-data");
const agent_instance_data_2 = require("../agent-instance-data");
const agent_events_contracts_1 = require("../../common/agent-events/agent-events-contracts");
const utils_1 = require("../utils");
const build_args_dto_1 = require("./build-args-dto");
const cockpit_notifier_1 = require("../../common/agent-events/cockpit-notifier");
const interface_1 = require("../../build-scanner/source-map-eraser/interface");
const fs_1 = require("fs");
const path_1 = require("path");
const sl_env_vars_1 = require("../../common/constants/sl-env-vars");
const files_utils_1 = require("../../common/utils/files-utils");
const validation_utils_1 = require("../../common/utils/validation-utils");
const constants_1 = require("../constants/constants");
class BuildExecutor extends base_executor_1.BaseExecutor {
    constructor() {
        super(...arguments);
        this.commandName = 'build';
    }
    innerExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.printAgentVersionAndAgentId();
            const mappedArgs = this.mapArgs(args);
            yield this.setConfigFromRemote(mappedArgs);
            try {
                yield new cia_1.CIA().run(mappedArgs);
                if (mappedArgs.awsConfigure) {
                    this.logger.lifecycle('AWS Configure was enabled. Writing sl-config.json file to workspace sub-directories.');
                    this.writeSlConfigFileRecursive(mappedArgs, mappedArgs.workspacepath);
                }
            }
            catch (err) {
                this.logError(err);
                return false;
            }
            return true;
        });
    }
    writeSlConfigFile(args, filePath, commonSrcPrefix, slMapping) {
        var _a;
        const slConfig = {
            token: args.token,
            buildSessionId: args.buildSessionId,
            collectorUrl: args.collectorUrl,
            projectRoot: args.projectRoot,
            labId: args.labid,
            commonSrcPrefix,
            slMapping,
            proxy: args.proxy,
            rawCoverage: args.rawCoverage
        };
        if ((_a = args.awsConfigKeysToIgnore) === null || _a === void 0 ? void 0 : _a.length) {
            Object.keys(slConfig).forEach(key => {
                if (args.awsConfigKeysToIgnore.includes(key)) {
                    delete slConfig[key];
                }
            });
        }
        const configFile = (0, path_1.join)(filePath, 'sl-config.json');
        (0, fs_1.writeFileSync)(configFile, JSON.stringify(slConfig, null, 2));
        this.logger.info(`sl-config.json file was written to ${filePath}`);
    }
    // This method will return all sub-directories of the workspace directory. We store the sl-config in each of them in order to make the config file always accessible for our Node Lambda layer
    getWorkspaceSubDirectories(directory) {
        const subDirectories = [];
        const filesAndDirectories = (0, fs_1.readdirSync)(directory);
        for (const item of filesAndDirectories) {
            const itemPath = (0, path_1.join)(directory, item);
            const stats = (0, fs_1.statSync)(itemPath);
            if (stats.isDirectory()) {
                subDirectories.push(itemPath);
                const subSubDirectories = this.getWorkspaceSubDirectories(itemPath);
                subDirectories.push(...subSubDirectories);
            }
        }
        return subDirectories;
    }
    writeSlConfigFileRecursive(args, directory) {
        // Get the project paths from project-files.json
        const { files, slMapping } = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(process.cwd(), 'project-files.json'), 'utf8'));
        (0, fs_1.unlinkSync)((0, path_1.join)(process.cwd(), 'project-files.json'));
        const commonSrcPrefix = files_utils_1.FilesUtils.commonPathPrefix(files);
        // Write the initial sl-config.json file
        this.writeSlConfigFile(args, directory, commonSrcPrefix, slMapping);
        const subDirectories = this.getWorkspaceSubDirectories(directory);
        // Write the sl-config.json file to all sub-directories
        subDirectories.forEach(subDirectory => {
            this.writeSlConfigFile(args, subDirectory, commonSrcPrefix, slMapping);
        });
    }
    setConfigFromRemote(mappedArgs) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            mappedArgs.removeSensitiveData = this.agentRemoteConfig.removeSensitiveData || false;
            mappedArgs.awsConfigure = this.agentRemoteConfig.awsConfigure || (mappedArgs.awsConfigure || false);
            mappedArgs.useRelativeSlMapping = this.agentRemoteConfig.useRelativeSlMapping || (mappedArgs.useRelativeSlMapping || false);
            mappedArgs.enableDiagnostic = !!this.agentRemoteConfig.enableDiagnostic;
            mappedArgs.experimentalSizeReduction = !!this.agentRemoteConfig.experimentalSizeReduction;
            mappedArgs.splitPreambleIntoFile = mappedArgs.splitPreambleIntoFile || !!this.agentRemoteConfig.splitPreambleIntoFile;
            mappedArgs.preambleFileName = mappedArgs.preambleFileName || this.agentRemoteConfig.preambleFileName || constants_1.PREAMBLE_DEFAULT_FILE_NAME;
            mappedArgs.preambleFileUrl = mappedArgs.preambleFileUrl || this.agentRemoteConfig.preambleFileUrl || '';
            mappedArgs.toggleBasedBrowserInstrumentation = mappedArgs.toggleBasedBrowserInstrumentation || !!this.agentRemoteConfig.toggleBasedBrowserInstrumentation;
            mappedArgs.useBranchCoverage = !!this.agentRemoteConfig.useBranchCoverage;
            mappedArgs.newInstrumenter = mappedArgs.newInstrumenter || !!this.agentRemoteConfig.newInstrumenter;
            mappedArgs.scanDotFolders = mappedArgs.scanDotFolders || !!this.agentRemoteConfig.scanDotFolders;
            mappedArgs.reduceInstrumentedFileSize = mappedArgs.reduceInstrumentedFileSize || !!this.agentRemoteConfig.reduceInstrumentedFileSize;
            mappedArgs.excludeTokenFromBrowserConfig = mappedArgs.excludeTokenFromBrowserConfig || !!this.agentRemoteConfig.excludeTokenFromBrowserConfig;
            mappedArgs.overrideServer = this.agentRemoteConfig.overrideServer || mappedArgs.overrideServer;
            mappedArgs.compressSlMapping = mappedArgs.compressSlMapping || !!this.agentRemoteConfig.compressSlMapping;
            mappedArgs.ctxPropagationOnly = this.agentRemoteConfig.ctxPropagationOnly || !!mappedArgs.ctxPropagationOnly;
            mappedArgs.enableLineCoverage = mappedArgs.enableLineCoverage || !!this.agentRemoteConfig.enableLineCoverage;
            mappedArgs.embedCorrectUniqueId = mappedArgs.embedCorrectUniqueId || !!this.agentRemoteConfig.embedCorrectUniqueId;
            mappedArgs.skipInstrumentingFilesWithoutSourceMap = mappedArgs.skipInstrumentingFilesWithoutSourceMap || !!this.agentRemoteConfig.skipInstrumentingFilesWithoutSourceMap;
            mappedArgs.recognizeBabelCreateClass = mappedArgs.recognizeBabelCreateClass || !!this.agentRemoteConfig.recognizeBabelCreateClass;
            mappedArgs.preferSourceMapFromFile = mappedArgs.preferSourceMapFromFile || !!this.agentRemoteConfig.preferSourceMapFromFile;
            mappedArgs.enrichByMethodRange = mappedArgs.enrichByMethodRange || !!this.agentRemoteConfig.enrichByMethodRange;
            /*
             * Note: we check for `undefined`s, and not for array length.
             * This way we allow to overwrite the remote config (and env in mapArgs) with an empty string to disable
             * domain-based check. E.g. if remote config sets some domains, and we pass nothing in CLI, and we don't set the
             * env var, value from remote config is used. But if we pass an empty string with either CLI or env,
             * the value from remote config is overwritten and domain-based check is disabled. It seems the most natural
             * behavior both code-wise and user-wise.
             */
            mappedArgs.allowedDomains = (_c = (_a = mappedArgs.allowedDomains) !== null && _a !== void 0 ? _a : (_b = this.agentRemoteConfig.allowedDomains) === null || _b === void 0 ? void 0 : _b.split(',')) !== null && _c !== void 0 ? _c : [];
            /* When embedCorrectUniqueId is true, we need to ensure useRelativeSlMapping is also true.
             * This prevents mismatches between scan and instrument operations across different machines:
             * - Without relative paths: Each machine uses its absolute path as uniqueId
             *   (e.g., /home/user1/project vs /home/user2/project)
             * - With relative paths: Both machines use the same relative path structure
             *   (e.g., ./src/file.js), ensuring consistent footprints regardless of machine
             */
            if (mappedArgs.embedCorrectUniqueId) {
                mappedArgs.useRelativeSlMapping = true;
            }
            mappedArgs.excludeNestedMethods = mappedArgs.excludeNestedMethods || !!this.agentRemoteConfig.excludeNestedMethods;
            if (mappedArgs.excludeNestedMethods) {
                mappedArgs.hashIncludeNestedMethods = true;
            }
            else {
                mappedArgs.hashIncludeNestedMethods = mappedArgs.hashIncludeNestedMethods || !!this.agentRemoteConfig.hashIncludeNestedMethods;
            }
            if (typeof mappedArgs.sourceHash === 'undefined') {
                mappedArgs.sourceHash = !!this.agentRemoteConfig.sourceHash;
            }
            if (this.agentRemoteConfig.partialBuildMapping) {
                mappedArgs.partialBuildMapping = this.agentRemoteConfig.partialBuildMapping;
            }
            mappedArgs.additionalGitDetails = !!this.agentRemoteConfig.additionalGitDetails || false;
            mappedArgs.rawCoverage = this.agentRemoteConfig.rawCoverage !== undefined ? this.agentRemoteConfig.rawCoverage : !!mappedArgs.rawCoverage;
            if (mappedArgs.useRelativeSlMapping) {
                cockpit_notifier_1.CockpitNotifier.sendGenericMessage('Relative sl-mapping feature was turned on');
                if (mappedArgs.useModulePrefix) {
                    const message = 'Both \'relativeSlMapping\' and \'useModulePrefix\' turned on, it might affects coverage correctness';
                    cockpit_notifier_1.CockpitNotifier.sendWarning(message);
                    this.logger.lifecycle(message);
                }
            }
        });
    }
    setAliasCommand(alias) {
        this.commandName = alias;
        return this;
    }
    validateArgs(args) {
        var _a;
        this.handleLegacyCommand(args);
        if ((args.workspacepath === args.outputpath) && args.outputpath) {
            this.logger.lifecycle('\'outputpath\' and \'workspacepath\' cannot be the same');
            return false;
        }
        if (((_a = args.allowCORS) === null || _a === void 0 ? void 0 : _a.length) && !args.enableOpenTelemetry) {
            this.logger.lifecycle(`--enableOpenTelemetry must be specified when using --allowCORS option.`);
            return false;
        }
        if (args.dependency || args.dependenciesFile) {
            if (args.workspacepath) {
                this.logger.lifecycle('\'workspacepath\' is ignored when submitting an integration build');
            }
            if (args.scm) {
                this.logger.lifecycle('\'scm\' is ignored when submitting an integration build');
            }
        }
        else {
            if (!args.workspacepath) {
                this.logger.lifecycle('\'workspacepath\' argument is required but was not specified');
                return false;
            }
            if (!args.scm) {
                this.logger.lifecycle('\'scm\' argument is required but was not specified');
                return false;
            }
        }
        if (args.preambleFileUrl && !validation_utils_1.ValidationUtils.validatePath(args.preambleFileUrl)) {
            this.logger.lifecycle(`'preambleFileUrl' argument must be a valid URL either full (https://example.com/a/b/c) or relative (a/b/c)`);
            return false;
        }
        if ((args.autoResolveProjectRoot && args.embedCorrectUniqueId) && !args.instrumentForBrowsers) {
            this.logger.lifecycle('Both autoResolveProjectRoot and embedCorrectUniqueId cannot be true at the same time. For Node application use autoResolveProjectRoot and for Browser use embedCorrectUniqueId.');
            return false;
        }
        if (args.toggleBasedBrowserInstrumentation && !args.splitPreambleIntoFile) {
            this.logger.lifecycle('toggleBasedBrowserInstrumentation can only be used when splitPreambleIntoFile is true.');
            return false;
        }
        this.resolvePathArgs(args);
        return true;
    }
    handleLegacyCommand(args) {
        var _a;
        const mainCommand = (_a = args === null || args === void 0 ? void 0 : args.args) === null || _a === void 0 ? void 0 : _a[0];
        if (mainCommand === contracts_1.COMMANDS.BUILD) {
            this.logger.lifecycle(`'build' command is deprecated and should be replaced by the 'scan' command `);
        }
    }
    notifyAgentStarted(agentInstanceData, cmd) {
        const _super = Object.create(null, {
            notifyAgentStarted: { get: () => super.notifyAgentStarted }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const buildScannerAgentInstanceData = new agent_instance_data_1.AgentInstanceData(agent_events_contracts_1.AgentTypes.BUILD_SCANNER, agent_events_contracts_1.AgentTechnologies.NODEJS);
            return _super.notifyAgentStarted.call(this, buildScannerAgentInstanceData, cmd);
        });
    }
    resolvePathArgs(args) {
        if (args.workspacepath) {
            args.workspacepath = (0, utils_1.resolvePath)('workspacepath', args.workspacepath);
        }
        if (args.dependenciesFile) {
            args.dependenciesFile = (0, utils_1.resolvePath)('dependenciesFile', args.dependenciesFile);
        }
    }
    /*
      todo argument type is inconsistent, it expects unmapped args (and such are used in tests), but mappedArgs are passed in `mapArgs` method
      I limited the fields used, because of error after adding `allowedDomains` (it has a different raw type and different after mapping)
    */
    handleProjectRootSettings(args) {
        var _a;
        // If instrumentForBrowser is true and autoResolveProjectRoot is true, we need to turn off autoResolveProjectRoot and turn on embedCorrectUniqueId automatically
        // This is because for browser the embedCorrectUniqueId is the way to resolve the issues around mapping/paths
        if (args.instrumentForBrowsers && args.autoResolveProjectRoot) {
            args.autoResolveProjectRoot = false;
            args.embedCorrectUniqueId = true;
            this.logger.lifecycle('Auto resolving project root was turned off and embedCorrectUniqueId was turned on automatically because instrumentForBrowsers is true.');
        }
        // If autoResolveProjectRoot is true but customer provided a projectRoot, we need to turn off autoResolveProjectRoot and keep the projectRoot as is
        if (args.autoResolveProjectRoot && ((_a = args.projectRoot) === null || _a === void 0 ? void 0 : _a.length)) {
            args.autoResolveProjectRoot = false;
            this.logger.lifecycle(`Auto resolving project root was turned off because a projectRoot was provided: ${args.projectRoot}`);
        }
        // If autoResolveProjectRoot is true and awsConfigure is true, we need to turn off autoResolveProjectRoot since the Lambda Layer already implements the project root resolution
        if (args.autoResolveProjectRoot && args.awsConfigure) {
            args.autoResolveProjectRoot = false;
            this.logger.lifecycle('Auto resolving project root was turned off because awsConfigure is true.');
        }
    }
    /*
       The cia Receives parameters with different name/casing so as part of mapping those need to adjust.
       appName => appname.
       buildName => build.
       branchName => branch.
       customerId => customerid
     */
    mapArgs(args) {
        var _a, _b;
        let excludeSourceMapFiles;
        if (args.excludeSourceMapFiles === undefined) {
            excludeSourceMapFiles = interface_1.SourceMapsEraserModes.None;
        }
        else if (args.excludeSourceMapFiles === true) {
            excludeSourceMapFiles = interface_1.SourceMapsEraserModes.SkipCopy;
        }
        else {
            excludeSourceMapFiles = args.excludeSourceMapFiles;
        }
        let partialBuildMapping;
        if (args.partialBuildMapping !== undefined) {
            partialBuildMapping = +args.partialBuildMapping;
        }
        else if (sl_env_vars_1.SlEnvVars.CIA.partialBuildMapping() !== undefined) {
            partialBuildMapping = sl_env_vars_1.SlEnvVars.CIA.partialBuildMapping();
        }
        else {
            partialBuildMapping = 0;
        }
        const createdArgs = build_args_dto_1.BuildArgsDTO.create(args);
        const mappedArgs = Object.assign(Object.assign(Object.assign({}, createdArgs), this.baseData), { appname: this.baseData.appName, build: this.baseData.buildName, branch: this.baseData.branchName, agentId: agent_instance_data_2.AgentInstanceDataFactory.getOrCreateAgentInstanceData().agentId, customerId: this.baseData.customerid, ctxPropagationOnly: args.ctxPropagationOnly, partialBuildMapping,
            excludeSourceMapFiles, excludeTokenFromBrowserConfig: createdArgs.excludeTokenFromBrowserConfig || sl_env_vars_1.SlEnvVars.CIA.excludeTokenFromBrowserConfig(), overrideServer: createdArgs.overrideServer || sl_env_vars_1.SlEnvVars.CIA.overrideServer(), splitPreambleIntoFile: createdArgs.splitPreambleIntoFile || sl_env_vars_1.SlEnvVars.CIA.splitPreambleIntoFile(), enableLineCoverage: createdArgs.enableLineCoverage || sl_env_vars_1.SlEnvVars.CIA.enableLineCoverage(), embedCorrectUniqueId: createdArgs.embedCorrectUniqueId || sl_env_vars_1.SlEnvVars.CIA.embedCorrectUniqueId(), useRelativeSlMapping: createdArgs.useRelativeSlMapping || sl_env_vars_1.SlEnvVars.CIA.useRelativeSlMapping(), preambleFileName: createdArgs.preambleFileName || sl_env_vars_1.SlEnvVars.CIA.preambleFileName(), preambleFileUrl: createdArgs.preambleFileUrl || sl_env_vars_1.SlEnvVars.CIA.preambleFileUrl(), autoResolveProjectRoot: createdArgs.autoResolveProjectRoot || sl_env_vars_1.SlEnvVars.CIA.autoResolveProjectRoot(), skipInstrumentingFilesWithoutSourceMap: createdArgs.skipInstrumentingFilesWithoutSourceMap || sl_env_vars_1.SlEnvVars.CIA.skipInstrumentingFilesWithoutSourceMap(), toggleBasedBrowserInstrumentation: createdArgs.toggleBasedBrowserInstrumentation || sl_env_vars_1.SlEnvVars.CIA.toggleBasedBrowserInstrumentation(), recognizeBabelCreateClass: createdArgs.recognizeBabelCreateClass || sl_env_vars_1.SlEnvVars.CIA.recognizeBabelCreateClass(), preferSourceMapFromFile: createdArgs.preferSourceMapFromFile || sl_env_vars_1.SlEnvVars.CIA.preferSourceMapFromFile(), enrichByMethodRange: createdArgs.enrichByMethodRange || sl_env_vars_1.SlEnvVars.CIA.enrichByMethodRange(), allowedDomains: (_b = (_a = args.allowedDomains) === null || _a === void 0 ? void 0 : _a.split(',')) !== null && _b !== void 0 ? _b : sl_env_vars_1.SlEnvVars.CIA.allowedDomains() });
        this.handleProjectRootSettings(mappedArgs);
        return mappedArgs;
    }
}
exports.BuildExecutor = BuildExecutor;
//# sourceMappingURL=build-executor.js.map