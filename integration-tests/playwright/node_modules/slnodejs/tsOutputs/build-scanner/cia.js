"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CIA = void 0;
const build_diff_process_1 = require("./build-diff-process");
const logger_1 = require("../common/logger");
const utils_1 = require("./utils");
const backend_proxy_with_default_client_1 = require("../common/http/backend-proxy-with-default-client");
const scm_factory_1 = require("../common/scm/scm-factory");
const dependency_utils_1 = require("../common/utils/dependency-utils");
const DefaultValuesResolver = require("./default-values-resolver");
const agentInstanceData = require("./current-agent-instance");
const utils = require("./utils.js");
const diagnostic_1 = require("./diagnostic");
const token_utils_1 = require("../common/utils/token-utils");
// TODO: make it in a same style as AgentFactory in test-listener
class CIA {
    run(buildArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setDefaultsArguments(buildArguments);
            const logger = logger_1.LoggerFactory.getCreateApplicationLogger();
            printConfiguration(buildArguments, logger);
            const parsedDependencies = this.tryParseDependenciesForIntegrationBuild(buildArguments, logger);
            const buildMappingProxy = backend_proxy_with_default_client_1.BackendProxyFactory.initWithDefaultClient(agentInstanceData, buildArguments, logger);
            yield this.runBuildDiffProcess(buildMappingProxy, parsedDependencies, buildArguments, logger);
        });
    }
    dryRun(dryRunProxy, buildArguments, logger) {
        this.setDefaultsArguments(buildArguments);
        buildArguments.isDryRunMode = true;
        buildArguments.enableDiagnostic = true;
        const diagnosticCollector = buildArguments.enableDiagnostic ? new diagnostic_1.DryRunDiagnosis(buildArguments.buildSessionId, dryRunProxy) : new diagnostic_1.NoneDiagnosis();
        return new build_diff_process_1.BuildDiffProcess(dryRunProxy, new scm_factory_1.ScmFactory(), [], logger, diagnosticCollector).run(buildArguments);
    }
    instrument(instrumentArguments) {
        const logger = logger_1.LoggerFactory.getCreateApplicationLogger();
        printConfiguration(instrumentArguments, logger);
        const backendProxy = backend_proxy_with_default_client_1.BackendProxyFactory.initWithDefaultClient(agentInstanceData, instrumentArguments, logger);
        const diagnosticCollector = new diagnostic_1.NoneDiagnosis();
        const buildDiffProcess = new build_diff_process_1.BuildDiffProcess(backendProxy, new scm_factory_1.ScmFactory(), [], logger, diagnosticCollector);
        return buildDiffProcess.instrument(instrumentArguments);
    }
    runBuildDiffProcess(backendProxy, parsedDependencies, buildArguments, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: add support of buildArguments.diagnosticThreshold
            const diagnosticCollector = buildArguments.enableDiagnostic ? new diagnostic_1.BuildScanDiagnosis(buildArguments.buildSessionId, backendProxy) : new diagnostic_1.NoneDiagnosis();
            const buildDiffProcess = new build_diff_process_1.BuildDiffProcess(backendProxy, new scm_factory_1.ScmFactory(), parsedDependencies, logger, diagnosticCollector);
            try {
                yield buildDiffProcess.run(buildArguments);
                yield shutdownAgent(logger, buildArguments);
            }
            catch (err) {
                logger.error('Shutdown agent: ' + err);
                yield shutdownAgent(logger, buildArguments);
                throw err;
            }
        });
    }
    setDefaultsArguments(buildArguments) {
        var _a;
        const defaults = this.createDefaults();
        for (const i in defaults) {
            if (!buildArguments[i]) {
                buildArguments[i] = defaults[i];
            }
        }
        buildArguments.includedFiles = (0, utils_1.expandCommaSeparatedValues)(buildArguments.includedFiles);
        buildArguments.excludedFiles = (0, utils_1.expandCommaSeparatedValues)(buildArguments.excludedFiles);
        buildArguments.recognizeBabelCreateClass = (_a = (buildArguments.recognizeBabelCreateClass || buildArguments.enrichByMethodRange)) !== null && _a !== void 0 ? _a : false; // when enriching by method range, automatically set this flag on
    }
    tryParseDependenciesForIntegrationBuild(buildArguments, logger) {
        try {
            if (buildArguments.dependency) {
                return dependency_utils_1.DependencyUtils.parseDependencies(buildArguments.dependency, logger);
            }
            else if (buildArguments.dependenciesFile) {
                return dependency_utils_1.DependencyUtils.parseDependenciesFile(utils.readJsonSync(buildArguments.dependenciesFile), logger);
            }
            else
                return [];
        }
        catch (err) {
            logger.error(`Error parsing dependencies ${err}`);
        }
    }
    createDefaults() {
        const dvr = new DefaultValuesResolver();
        return {
            'includedFiles': dvr.getIncludedFiles(),
            'excludedFiles': dvr.getExcludedFiles(),
            'sendCommitTitles': dvr.getSendCommitTitles(),
            'prefixesOfExcludedFiles': process.env['SL_prefixesOfExcludedFiles'] ? process.env['SL_prefixesOfExcludedFiles'] : '~, :, webpack, node_modules',
            'delayShutdownInSeconds': 30
        };
    }
}
exports.CIA = CIA;
function printConfiguration(cfg, logger) {
    logger.info('***************************************************************');
    logger.info('Current Configuration: ');
    logger.info('***************************************************************');
    for (const p in cfg) {
        if (typeof cfg[p] != 'function') {
            let value = cfg[p];
            if (p === token_utils_1.TOKEN_KEY) {
                value = (0, token_utils_1.obfuscateToken)(value);
            }
            logger.info(`${p}: ${value}`);
        }
    }
    logger.info('***************************************************************');
}
function shutdownAgent(logger, cfg) {
    return __awaiter(this, void 0, void 0, function* () {
        //TODO: [SLDEV-4709] Verify if we can remove this completely. Should check how SlNodeJS invokes it.
        if (cfg.sendLogs) {
            yield sendLogs(logger);
        }
    });
}
function sendLogs(logger) {
    return new Promise((resolve, _reject) => {
        logger.remoteStream.checkBuffer(true, _ => resolve());
    });
}
//# sourceMappingURL=cia.js.map