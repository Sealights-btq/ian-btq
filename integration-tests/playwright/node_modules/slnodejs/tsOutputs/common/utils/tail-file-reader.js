"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tailFileReader = void 0;
const fs_1 = require("fs");
class TailFileReader {
    read(inputFilePath, maxLineCount, encoding = 'utf8') {
        return __awaiter(this, void 0, void 0, function* () {
            const stat = yield fs_1.promises.stat(inputFilePath);
            const file = yield fs_1.promises.open(inputFilePath, 'r');
            try {
                let chars = 0;
                let lineCount = 0;
                let lines = '';
                while (true) {
                    if (lines.length > stat.size) {
                        lines = lines.substring(lines.length - stat.size);
                    }
                    if (lines.length >= stat.size || lineCount >= maxLineCount) {
                        if (TailFileReader.NEW_LINE_CHARACTERS.includes(lines[0])) {
                            lines = lines.substring(1);
                        }
                        return encoding === 'buffer' ? Buffer.from(lines, 'binary') : Buffer.from(lines, 'binary').toString(encoding);
                    }
                    const nextCharacter = yield this.readPreviousChar(stat, file, chars);
                    lines = nextCharacter + lines;
                    if (TailFileReader.NEW_LINE_CHARACTERS.includes(nextCharacter) && lines.length > 1) {
                        lineCount++;
                    }
                    chars++;
                }
            }
            finally {
                yield file.close();
            }
        });
    }
    readPreviousChar(stat, file, currentCharacterCount) {
        return __awaiter(this, void 0, void 0, function* () {
            const buffer = Buffer.alloc(1);
            const { bytesRead: _bytesRead } = yield file.read(buffer, 0, 1, stat.size - 1 - currentCharacterCount);
            return String.fromCharCode(buffer[0]);
        });
    }
}
TailFileReader.NEW_LINE_CHARACTERS = ['\n'];
exports.tailFileReader = new TailFileReader();
//# sourceMappingURL=tail-file-reader.js.map