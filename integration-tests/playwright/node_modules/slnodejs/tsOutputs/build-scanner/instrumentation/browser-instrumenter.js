var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var mkdirp = require('mkdirp');
var async = require('async');
const os = require('os');
const { promisify } = require('util');
const path = require('path');
var fileAndFolderUtils = require('../file-and-folder-utils');
const { CliProgress } = require("../../common/cli-progress");
var ValidationUtils = require("../../common/utils/validation-utils").ValidationUtils;
var MessagesFormatter = require("../../common/messages-formatter").MessagesFormatter;
var ConfigLoader = require("../../common/config-process/config-loader").ConfigLoader;
var SlEnvVars = require("../../common/constants/sl-env-vars").SlEnvVars;
var Constants = require("../../common/constants/constants").Constants;
const { FilesInstrumenter } = require("./files-instrumenter");
const { CockpitNotifier } = require("../../common/agent-events/cockpit-notifier");
const { AgentEventCode } = require("../../common/agent-events/agent-events-contracts");
var CiaEnvVars = SlEnvVars.CIA;
const request = require('sl-request');
const requestAsync = promisify(request);
const { OUT_OF_MEMORY } = require("./process-pool/contracts");
const { writeFileSync, mkdirSync, createWriteStream } = require('fs');
const { resolve, dirname } = require('path');
const { FilesUtils } = require('../../common');
const PARALLALIZATION_THRESHOLD = 0;
const OUT_OF_MEMORY_DOCUMENTATION_URL = 'https://sealights.atlassian.net/wiki/spaces/SUP/pages/561905721/NodeJS+-+JavaScript+heap+out+of+memory';
/**
 * * This class responsible to instrument a set of files with Sealights information.
 * @param {* Instrumentation options} opts
 * @param {* A logger} logger
 */
function BrowserInstrumenter(opts, logger, slMapper) {
    ValidationUtils.verifyNotNullOrEmpty(opts, "opts");
    ValidationUtils.verifyNotNullOrEmpty(logger, "logger");
    ValidationUtils.verifyNotNullOrEmpty(slMapper, "slMapper");
    this.cliProgress = new CliProgress(logger);
    this.opts = opts;
    this.logger = logger;
    this.slMapper = slMapper;
    this.files = {
        instrumented: [],
        notInstrumented: [],
        withInstrumentationErrors: [],
        withCopyErrors: []
    };
}
BrowserInstrumenter.prototype.instrument = function (callback) {
    const _this = this;
    ValidationUtils.verifyNotNullOrEmpty(callback, "callback");
    try {
        var err = this._validate(callback);
        const origCallback = callback;
        callback = function (...args) {
            var _a, _b;
            (_b = (_a = _this.cliProgress) === null || _a === void 0 ? void 0 : _a.stop) === null || _b === void 0 ? void 0 : _b.call(_a);
            origCallback(...args);
        };
        if (err) {
            this.logger.error(`Instrumentation failed due to invalid input. Error: ${err}`);
            return callback(err);
        }
        var hasPhysicalFiles = this.opts.files && this.opts.files.length > 0;
        if (!hasPhysicalFiles) {
            this.logger.warn("Didn't find any files which require instrumentation. Skipping browser instrumentation.");
            return callback();
        }
        this.logger.info("Starting instrumentation process.");
        this._processFiles(function () {
            _this._onComplete(callback);
        });
    }
    catch (e) {
        this.logger.error(`Failed during instrumentation. Error: ${e}`);
        return callback(e);
    }
};
BrowserInstrumenter.prototype._printSummaries = function () {
    var summary = "Instrumentation summary:" +
        "\n\tInstrumented files: " + this.files.instrumented.length +
        "\n\tFiles copied as is (not instrumented): " + this.files.notInstrumented.length +
        "\n\tFiles with instrumentation errors: " + this.files.withInstrumentationErrors.length +
        "\n\tFiles with copy errors: " + this.files.withCopyErrors.length;
    this.logger.info(summary);
};
BrowserInstrumenter.prototype._onComplete = function (callback) {
    var _this = this;
    if (this.opts.copyAllFilesToOutput) {
        fileAndFolderUtils.copyDir(this.opts.sourceRoot, this.opts.outputPath, this.opts.files, function (err) {
            _this.logger.info(`Finished copying all files to output. Error: ${err}`);
            // If embedCorrectUniqueId is enabled, wait for it to complete before continuing
            if (_this.opts.embedCorrectUniqueId) {
                _this._embedCorrectUniqueIdForAllFiles()
                    .then(() => {
                    _this._printSummaries();
                    return callback(err, _this.files);
                })
                    .catch((embedError) => {
                    _this.logger.error(`Error embedding unique ids: ${embedError}`);
                    return callback(embedError, _this.files);
                });
            }
            else {
                _this._printSummaries();
                return callback(err, _this.files);
            }
        });
    }
    else {
        _this._printSummaries();
        return callback(null, _this.files);
    }
};
BrowserInstrumenter.prototype._onFileCopied = function (inputFile) {
    this.files.notInstrumented.push(inputFile);
    this.logger.debug(`File '${inputFile}' copied successfully.`);
};
BrowserInstrumenter.prototype._onFileCopyError = function (inputFile, errorMsg) {
    this.files.withCopyErrors.push({
        file: inputFile,
        error: errorMsg
    });
    this.logger.warn(`Had error while coping '${inputFile}'. ${errorMsg}.`);
};
BrowserInstrumenter.prototype._onFileWithInstrumentationError = function (inputFile, errorMsg) {
    this.files.withInstrumentationErrors.push({
        file: inputFile,
        error: errorMsg
    });
    this.logger.warn(`Had error while processing '${inputFile}'. ${errorMsg}. File will be copied as is.`);
};
BrowserInstrumenter.prototype._onFileInstrumented = function (inputFile) {
    this.files.instrumented.push(inputFile);
    this.logger.debug(`Processed '${inputFile}'.`);
};
BrowserInstrumenter.prototype._embedCorrectUniqueIdForAllFiles = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const BATCH_SIZE = this.opts.embedCorrectUniqueIdFileBatchSize;
        const files = [...this.files.instrumented];
        // Process files in batches
        for (let i = 0; i < files.length; i += BATCH_SIZE) {
            const batchNumber = i / BATCH_SIZE + 1;
            const totalBatches = Math.ceil(files.length / BATCH_SIZE);
            this.logger.debug(`Embedding correct unique id for batch ${batchNumber} of ${totalBatches}`);
            const batch = files.slice(i, i + BATCH_SIZE);
            const promises = batch.map(inputFile => this._embedUniqueIdForFile(inputFile));
            try {
                yield Promise.all(promises);
                this.logger.debug(`Batch processing completed for batch ${batchNumber} of ${totalBatches}`);
            }
            catch (error) {
                this.logger.error(`Batch processing failed: ${error}`);
            }
        }
    });
};
BrowserInstrumenter.prototype._embedUniqueIdForFile = function (inputFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const inputFilePath = path.resolve(this.opts.sourceRoot, inputFile);
        const outputFilePath = path.resolve(this.opts.outputPath, inputFile);
        try {
            this.logger.debug(`Embedding correct unique id for '${inputFilePath}'.`);
            const slMappingContent = this.slMapper.getEmbeddedFileContent(inputFilePath);
            if (!slMappingContent.length) {
                return;
            }
            yield new Promise((resolve, reject) => {
                const writeStream = createWriteStream(outputFilePath, { flags: 'a' });
                writeStream.on('error', (error) => {
                    this.logger.error(`Write stream error for '${inputFilePath}': ${error}`);
                    reject(error);
                });
                writeStream.on('finish', () => {
                    this.logger.debug(`Embedded correct unique id for '${inputFilePath}'.`);
                    resolve();
                });
                writeStream.write(slMappingContent);
                writeStream.end();
            });
        }
        catch (error) {
            this.logger.error(`Failed to embed correct unique id for '${inputFilePath}'. Error: ${error}`);
            throw error;
        }
    });
};
BrowserInstrumenter.prototype._validate = function (callback) {
    var _a, _b;
    var opts = this.opts;
    if (opts.instrumentationType != "browser") {
        return new Error("instrumentationType must be 'browser'");
    }
    if (!opts.extensionsToInstrument || opts.extensionsToInstrument.length === 0) {
        return new Error("'extensionsToInstrument' must specified");
    }
    var hasPhysicalFiles = opts.files && opts.files.length > 0;
    if (hasPhysicalFiles) {
        if (!opts.outputPath) {
            return new Error("outputPath was not specified");
        }
        if (!opts.sourceRoot) {
            return new Error("sourceRoot was not specified");
        }
    }
    if (!opts.server) {
        return new Error("server was not specified");
    }
    if (!opts.token) {
        return new Error("token was not specified");
    }
    if (!opts.customerId) {
        return new Error("customerId was not specified");
    }
    if (!opts.workspacepath) {
        return new Error("workspacepath was not specified");
    }
    if (opts.excludeTokenFromBrowserConfig && !((_a = opts.collectorUrl) === null || _a === void 0 ? void 0 : _a.length) && !((_b = opts.overrideServer) === null || _b === void 0 ? void 0 : _b.length)) {
        this.logger.warn("excludeTokenFromBrowserConfig is set to true, but no collectorUrl or overrideServer was specified");
    }
    //All good.
    return null;
};
function addHtmlTag(preambleHeader, sourceUrl, loadedFlag) {
    const allowedDomainsCondition = `(${Constants.ALLOWED_DOMAINS_CONFIG_PROP}.length === 0 || ${Constants.ALLOWED_DOMAINS_CONFIG_PROP}.includes(window.location.hostname))`;
    preambleHeader.push("if(!window.$Sealights." + loadedFlag + " && !" + Constants.SKIP_BROWSER_AGENT + ` && ${allowedDomainsCondition}) {`, "   var script   = document.createElement(\"script\");", "   script.type  = \"text/javascript\";", "   script.src   = \"" + sourceUrl + "\";", "   var head     = document.head || document.getElementsByTagName && document.getElementsByTagName('head')[0]", "   if (head) { head.appendChild(script); window.$Sealights." + loadedFlag + " = true; } else { /* Unsupported/restricted browser */ }", "}");
}
BrowserInstrumenter.prototype._createPreamble = function (preambleFileName, preambleFileUrl, callback) {
    var _a;
    var opts = this.opts;
    var agentUrl = opts.collectorUrl || opts.server;
    if (agentUrl[agentUrl.length] != '/')
        agentUrl += '/';
    agentUrl += 'v1/agents/browser/recommended?redirect=1&customerId=' + encodeURIComponent(opts.customerId);
    var workspacePath = opts.workspacepath;
    if (CiaEnvVars.getSourceRoot() != null) {
        workspacePath = CiaEnvVars.getSourceRoot();
        this.logger.info("Overriding 'workspacepath' with 'Source Root'. Old: '" + opts.workspacepath + "', New: '" + workspacePath + "'.");
    }
    var lastChar = workspacePath[workspacePath.length - 1];
    if (lastChar != "\\" && lastChar != "/") {
        workspacePath = workspacePath + "/";
    }
    var config = JSON.stringify(this.createConfigObject(opts, workspacePath), null, '  ');
    var slConfigVar = Constants.SL_CONFIG_VAR;
    const preambleUrl = `${preambleFileUrl ? FilesUtils.ensureTrailingSlash(preambleFileUrl) : ''}${preambleFileName}`;
    const preambleHeader = [
        'window.$Sealights = window.$Sealights || {};',
        `if(window && !window.$Sealights['${opts.appName}/${opts.branch}']){`,
        '\tvar script = document.createElement("script");',
        '\tscript.type = "text/javascript";',
        `\tscript.src = "${preambleUrl}";`,
        '\tvar head = document.head || document.getElementsByTagName && document.getElementsByTagName("head")[0];',
        '\tif (head) { head.appendChild(script); } else { /* Unsupported/restricted browser */ }',
        `\twindow.$Sealights['${opts.appName}/${opts.branch}'] = true`,
        '}'
    ];
    // If ctxPropagationOnly is enabled in the ops, just add the OTEL script
    if (opts.ctxPropagationOnly) {
        const OTELPluginVersion = '1.0.2';
        const OTELPluginURL = ((_a = opts.collectorUrl) === null || _a === void 0 ? void 0 : _a.length) ? `${opts.collectorUrl}/browser-otel?version=${OTELPluginVersion}` : `https://agents.sealights.co/browser-otel/${OTELPluginVersion}/bundle.js`;
        const ctxOnlyPreambleScript = [
            'var script = document.createElement("script");',
            'script.type = "text/javascript";',
            `script.src = "${OTELPluginURL}";`,
            'var head = document.head || document.getElementsByTagName && document.getElementsByTagName("head")[0];',
            'if (head) { head.appendChild(script); } else { /* Unsupported/restricted browser */ }',
        ];
        return callback(preambleHeader, ctxOnlyPreambleScript);
    }
    var preambleFile = [
        "var " + slConfigVar + " = " + config + ";\n" +
            "window.$Sealights = window.$Sealights || {};\n" +
            "if(window && window.$SealightsAgent){\n" +
            "   window.$SealightsAgent.createInstance(" + slConfigVar + ")\n" +
            "} else {\n" +
            "   window.$Sealights.components = window.$Sealights.components || {};\n" +
            "   window.$Sealights.components[\"" + this.opts.buildSessionId + "\"] = " + slConfigVar + ";" +
            "   document.addEventListener(\"DOMContentLoaded\", function(event) {\n" +
            "       document.body.dataset.components = JSON.stringify(window.$Sealights.components || {});\n" +
            "   });" +
            "}"
    ];
    if (this.slMapper && opts.slMappingUrl) {
        this.slMapper.writeToFile();
        addHtmlTag(preambleFile, opts.slMappingUrl, "slMappingAdded");
    }
    if (opts.compressSlMapping) {
        // Get the latest recommended version of the agent for the customer
        // If the version is less than or equal to 6.1.645 or we are unable to determine it, upgrade to the latest version
        this._isRedirectVersionGreater(agentUrl).then(isCompressionAvailableInVersion => {
            if (!isCompressionAvailableInVersion) {
                // Removing the customerId from the URL to prevent the agent from being downloaded with the customerId, hence the agent will be downloaded with the latest version
                agentUrl = agentUrl.split('&customerId=')[0];
            }
            addHtmlTag(preambleFile, agentUrl, "scriptAdded");
            callback(preambleHeader, preambleFile);
        });
    }
    else {
        addHtmlTag(preambleFile, agentUrl, "scriptAdded");
        callback(preambleHeader, preambleFile);
    }
};
// Latest version as time of writing this code is 6.1.645, if the version is less than this or equal, we will upgrade to the latest version
BrowserInstrumenter.prototype._isRedirectVersionGreater = function (agentUrl, targetVersion = '6.1.645') {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const response = yield requestAsync({
                url: agentUrl,
                method: 'GET',
                followRedirect: false, // Prevents automatic following of redirects
            });
            if (response.statusCode === 301 || response.statusCode === 302) {
                // Get the URL from the 'location' header
                const redirectUrl = response.headers['location'];
                // Extract version from URL using regex
                const versionMatch = redirectUrl === null || redirectUrl === void 0 ? void 0 : redirectUrl.match(/\/(\d+\.\d+\.\d+)\//);
                if (versionMatch) {
                    const version = versionMatch[1]; // Extracted version
                    // Compare versions and return the result
                    const isVersionSupported = isVersionGreaterThan(version, targetVersion);
                    if (isVersionSupported) {
                        this.logger.info(`SL Mapping compression was enabled and the recommended version supports it. The browser agent will be downloaded with version ${version}.`);
                    }
                    else {
                        this.logger.warn('SL Mapping compression was enabled but the recommended version does not support it. The browser agent will be automatically upgraded to the latest version.');
                    }
                    return isVersionSupported;
                }
                else {
                    this.logger.warn('SL Mapping compression was enabled but failed to extract version from redirect URL for browser-agent download. The browser agent will be automatically upgraded to the latest version.');
                    return false;
                }
            }
            else {
                this.logger.warn('SL Mapping compression was enabled but no redirect URL was found for browser-agent download. The browser agent will be automatically upgraded to the latest version.');
                return false;
            }
        }
        catch (err) {
            this.logger.error(`Failed to get redirect URL for browser-agent download. The browser agent will be automatically upgraded to the latest version. Error: ${err}`);
            return false;
        }
    });
};
function isVersionGreaterThan(version1, version2) {
    const v1Parts = version1.split('.').map(Number);
    const v2Parts = version2.split('.').map(Number);
    for (let i = 0; i < v1Parts.length; i++) {
        if (v1Parts[i] > v2Parts[i])
            return true;
        if (v1Parts[i] < v2Parts[i])
            return false;
    }
    return false;
}
BrowserInstrumenter.prototype._processFiles = function (callback) {
    const relativeNames = this.opts.files;
    this._createPreamble(this.opts.preambleFileName, this.opts.preambleFileUrl, (preambleHeader, preambleFile) => {
        var _a, _b;
        this.logger.info(`Starting to process files. Number of files to process: ${relativeNames.length}`);
        var extensions = {};
        this.opts.extensionsToInstrument.map(function (ext) {
            extensions[ext] = true;
        });
        this.opts.extensionsToInstrument = extensions;
        (_b = (_a = this.cliProgress) === null || _a === void 0 ? void 0 : _a.start) === null || _b === void 0 ? void 0 : _b.call(_a, {
            total: relativeNames.length,
            startValue: 0
        });
        //Verify the output folder exists
        if (this.opts.outputPath) {
            mkdirp.sync(this.opts.outputPath);
            if (this.opts.splitPreambleIntoFile) {
                // Resolve the full path for the output file
                const fullPath = resolve(this.opts.outputPath, this.opts.preambleFileName);
                // Ensure the directory exists
                mkdirSync(dirname(fullPath), { recursive: true });
                writeFileSync(fullPath, preambleFile.join('\n'), 'utf8');
            }
        }
        const experimentalSizeReduction = this.opts.experimentalSizeReduction || CiaEnvVars.useExperimentalSizeReduction();
        const splitPreambleIntoFile = this.opts.splitPreambleIntoFile || CiaEnvVars.splitPreambleIntoFile();
        // TODO - remove after new instrumenter has enough usage.
        const newInstrumenter = this.opts.newInstrumenter || CiaEnvVars.useNewInstrumenter();
        const reduceInstrumentedFileSize = this.opts.reduceInstrumentedFileSize || CiaEnvVars.reduceInstrumentedFileSize();
        const skipInstrumentingFilesWithoutSourceMap = this.opts.skipInstrumentingFilesWithoutSourceMap || CiaEnvVars.skipInstrumentingFilesWithoutSourceMap();
        const toggleBasedBrowserInstrumentation = this.opts.toggleBasedBrowserInstrumentation || CiaEnvVars.toggleBasedBrowserInstrumentation();
        //const shouldForceInstrumentationFileSizeReduction = !this.opts.usebranchcoverage && !CiaEnvVars.reduceInstrumentedFileSize();
        const config = {
            useRelativeSlMapping: this.opts.useRelativeSlMapping,
            workspacePath: this.opts.workspacepath,
            buildSessionId: this.opts.buildSessionId,
            esModules: !!this.opts.esModules,
            sourceRoot: this.opts.sourceRoot,
            outputPath: this.opts.outputPath,
            excludedPaths: this.opts.excludedPaths,
            extensionsToInstrument: this.opts.extensionsToInstrument,
            shouldMinifyInstrumentedOutput: CiaEnvVars.minifyInstrumentedOutput(),
            reduceInstrumentedFileSize,
            omitInstrumentedFunctionMap: CiaEnvVars.omitInstrumentedFunctionMap(),
            experimentalSizeReduction,
            useBranchCoverage: this.opts.usebranchcoverage,
            babylonPlugins: this.opts.babylonPlugins || [],
            excludeSourceMapFiles: this.opts.excludeSourceMapFiles,
            skipInstrumentingFilesWithoutSourceMap,
            newInstrumenter,
            toggleBasedBrowserInstrumentation,
            // newInstrumenter: newInstrumenter || shouldForceInstrumentationFileSizeReduction
        };
        const numOfCpu = os.cpus().length;
        const ProcessPool = this.tryImportProcessPool();
        const isEnoughFilesForParallalization = relativeNames.length > PARALLALIZATION_THRESHOLD;
        const shouldUseWorkers = !CiaEnvVars.inProcessInstrumentation() && isEnoughFilesForParallalization && ProcessPool;
        let pool = null;
        let filesInstrumenter = null;
        if (shouldUseWorkers) {
            this.logger.info(`Run instrumentation in ${numOfCpu} threads`);
            pool = new ProcessPool(numOfCpu, {
                config,
                preambleHeader: splitPreambleIntoFile ? preambleHeader : preambleFile,
            }, this.logger);
            pool.initSubprocesses();
        }
        else {
            filesInstrumenter = new FilesInstrumenter(config, splitPreambleIntoFile ? preambleHeader : preambleFile, this.logger, CockpitNotifier);
        }
        const startTime = new Date().getTime();
        let count = 0;
        q = async.queue((filename, cb) => {
            Promise.resolve()
                .then(() => {
                const skipInstrumentation = this.files.withInstrumentationErrors.some(x => x.file === filename);
                if (shouldUseWorkers) {
                    return pool.runInstrumentationTask({ inputFile: filename, skipInstrumentation });
                }
                return filesInstrumenter.processSingleFileAsync(filename, skipInstrumentation);
            })
                .then(result => {
                if (result.isInstrumented) {
                    this._onFileInstrumented(result.filename);
                }
                if (result.isInstrumentationError) {
                    this._onFileWithInstrumentationError(result.filename, result.instrumentationErrorMessage);
                }
                if (result.isCopied) {
                    this._onFileCopied(result.filename);
                }
                if (result.isCopyError) {
                    this._onFileCopyError(result.filename, result.copyErrorMessage);
                }
                cb && cb(null, result);
            })
                .catch(error => {
                if (error.message === OUT_OF_MEMORY) {
                    const cockpitMessage = `Got out of memory while instrumenting file '${filename}'.
    More memory can by provided by using '--max_old_space_size'. for more information please see ${OUT_OF_MEMORY_DOCUMENTATION_URL}`;
                    CockpitNotifier.sendError(cockpitMessage);
                }
                else {
                    this.logger.error(error.message);
                }
                CockpitNotifier.sendEvent(AgentEventCode.STATIC_INSTRUMENTATION_ERROR);
                this._onFileWithInstrumentationError(filename, error.message);
                q.push(filename, () => { });
                cb && cb(error, null);
            });
        }, numOfCpu),
            q.push(relativeNames, (err, name) => {
                var _a, _b;
                (_b = (_a = this.cliProgress) === null || _a === void 0 ? void 0 : _a.update) === null || _b === void 0 ? void 0 : _b.call(_a, { currentValue: count + 1 });
                count += 1;
            });
        q.drain = () => {
            this.logger.info('Draining the Queue.');
            pool === null || pool === void 0 ? void 0 : pool.close();
            var endTime = new Date().getTime();
            this.logger.info(`Processed [${count}] files in ${Math.floor((endTime - startTime) / 1000)} secs`);
            if (this.files.withCopyErrors.length > 0) {
                this.logger.warn(`The following ${this.files.withCopyErrors.length} file(s) had errors and were copied as-is:\n ${this._formatErrorMessage(this.files.withCopyErrors)}`);
            }
            callback && callback();
        };
    });
};
BrowserInstrumenter.prototype._formatErrorMessage = function (fileWithErrors) {
    var messageFormatter = new MessagesFormatter();
    var counter = 1;
    fileWithErrors.forEach(function (f) {
        var msg = "[" + counter++ + "] '" + f.file + "'. Error: '" + f.error;
        messageFormatter.addContent(msg);
    });
    return messageFormatter.content;
};
BrowserInstrumenter.prototype._setEmbedCorrectUniqueIdFileBatchSize = function (batchSize) {
    this.opts.embedCorrectUniqueIdFileBatchSize = batchSize;
};
BrowserInstrumenter.prototype.createConfigObject = function (opts, workspacePath) {
    var _a;
    // Should load all env vars starting With 'SL_'
    var agentConfig = new ConfigLoader().loadAgentConfiguration();
    this._setEmbedCorrectUniqueIdFileBatchSize(agentConfig.embedCorrectUniqueIdFileBatchSize.value);
    // TODO - why don't we copy opts as a whole and just override the fields that require logic?
    const configObject = {
        customerId: opts.customerId,
        appName: opts.appName,
        buildName: opts.build,
        branchName: opts.branch,
        server: opts.server,
        token: opts.token,
        buildSessionId: opts.buildSessionId,
        labId: opts.labId,
        collectorUrl: opts.collectorUrl,
        enabled: true,
        workspacepath: workspacePath,
        maxItemsInQueue: 500,
        registerShutdownHook: true,
        interval: 10,
        resolveWithoutHash: opts.resolveWithoutHash,
        delayShutdownInSeconds: opts.delayShutdownInSeconds,
        isUseNewUniqueId: SlEnvVars.isUseNewUniqueId(),
        footprintsEnableV6: agentConfig.footprintsEnableV6.value,
        footprintsBufferThresholdMb: agentConfig.footprintsBufferThresholdMb.value,
        footprintsCollectIntervalSecs: agentConfig.footprintsCollectIntervalSecs.value,
        footprintsSendIntervalSecs: agentConfig.executionQueryIntervalSecs.value,
        executionQueryIntervalSecs: agentConfig.executionQueryIntervalSecs.value,
        footprintsQueueSize: agentConfig.footprintsQueueSize.value,
        blockBrowserHttpTraffic: SlEnvVars.blockBrowserHttpTraffic(),
        enableOpenTelemetry: opts.enableOpenTelemetry,
        allowCORS: opts.allowCORS,
        footprintsMapping: opts.footprintsMapping,
        removeSensitiveData: opts.removeSensitiveData,
        experimentalSizeReduction: opts.experimentalSizeReduction,
        splitPreambleIntoFile: opts.splitPreambleIntoFile,
        preambleFileName: opts.preambleFileName,
        preambleFileUrl: opts.preambleFileUrl,
        excludeTokenFromBrowserConfig: opts.excludeTokenFromBrowserConfig,
        embedCorrectUniqueId: opts.embedCorrectUniqueId,
        [Constants.ALLOWED_DOMAINS_CONFIG_PROP_NAME]: (_a = opts.allowedDomains) !== null && _a !== void 0 ? _a : [], // should already be set to an empty array as a fallback, but we don't have TS here so nobody knows
    };
    if (opts.excludeTokenFromBrowserConfig) {
        delete configObject.token;
    }
    return configObject;
};
BrowserInstrumenter.prototype.tryImportProcessPool = function () {
    try {
        const { ProcessPool } = require('./process-pool/process-pool');
        return ProcessPool;
    }
    catch (e) {
        this.logger.error(`Could not import ProcessPool, using in process instrumentation. Error: ${e} `);
        return null;
    }
};
module.exports = BrowserInstrumenter;
//# sourceMappingURL=browser-instrumenter.js.map