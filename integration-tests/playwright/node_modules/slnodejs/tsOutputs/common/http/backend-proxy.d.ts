import { BuildSessionData, CreateBuildSessionIdResponse, GetVersionRequest, IBuildEndData, IColoredExecutionRequest, IHttpClient, ITestsRecommendationResponse, StartExecutionRequest, SubmitLogsRequest, UploadReportsBody, BuildMappingRequest, GetRemoteConfigRequest, AgentData, EndExecutionRequest, IBackendProxyConfig, SlAgentMetadata, NodeV8CoverageMap, NodeV8RawHitsPayload, NycCoverageMap, NycRawHitsPayload, IMetricsBatch, BuildMappingChunkRequest, IBuildMapEndRequest, InstrumentationMethodology, BuildMappingSubmitted } from './contracts';
import { IEventsFile } from '../events-process/events-contracts';
import { IAgentEventRequest } from '../agent-events/agent-events-contracts';
import { AgentInstanceData } from '../agent-instance-data';
import { Logger, IExecutionResponse, IIntegrationBuildDependency, IClockSyncResult } from '../contracts';
import { IFootprintsV6File } from '../footprints-process-v6/contracts';
import { IBackendProxy } from './backend-proxy-interface';
export declare class BackendProxy implements IBackendProxy {
    protected agentInstanceData: AgentInstanceData;
    protected config: IBackendProxyConfig;
    protected logger: Logger;
    protected client: IHttpClient;
    static DEFAULT_HTTP_MAX_ATTEMPTS: number;
    static DEFAULT_HTTP_ATTEMPT_INTERVAL: number;
    protected get httpMaxAttemps(): number;
    protected get httpAttemptInterval(): number;
    constructor(agentInstanceData: AgentInstanceData, config: IBackendProxyConfig, logger: Logger, client: IHttpClient);
    checkIfBuildMappingIsSubmitted(buildSessionId: string): Promise<BuildMappingSubmitted>;
    getBuildSession(buildSessionId: string, callback: (err: Error, response: BuildSessionData) => void): void;
    createBuildSessionId(request: BuildSessionData, callback: (err: Error, response: CreateBuildSessionIdResponse) => void): void;
    getInstrumentationMethodology(buildSessionId: string): Promise<{
        methodology: InstrumentationMethodology;
    }>;
    createBuildSessionIdPromise<T extends BuildSessionData>(request: T): Promise<string>;
    getRecommendedVersion(request: GetVersionRequest): Promise<any>;
    submitBuildMapping(request: BuildMappingRequest): Promise<any>;
    submitPartialBuildMapping(request: BuildMappingChunkRequest, agentId: string, buildSessionId: string, index: string): Promise<any>;
    submitBuildMappingEnd(request: IBuildMapEndRequest, buildSessionId: string): Promise<any>;
    submitLogs(request: SubmitLogsRequest): Promise<void>;
    submitAgentMetrics(request: IMetricsBatch): Promise<void>;
    getRemoteConfig(request: GetRemoteConfigRequest, callback: (err: Error, body: any) => void): void;
    getRemoteConfigPromise(request: GetRemoteConfigRequest): Promise<object>;
    startExecution(request: StartExecutionRequest, callback: (err: Error, body: any) => void): void;
    startColoredExecution(request: IColoredExecutionRequest): Promise<void>;
    testExecutionV4(labId: string, async?: boolean, executionId?: string): Promise<IExecutionResponse>;
    uploadReport(request: UploadReportsBody | AgentData, callback: (err: Error, body: any) => void): void;
    externalReport(request: UploadReportsBody | AgentData, callback: (err: Error, body: any) => void): void;
    endExecution(request: EndExecutionRequest, callback: (err: Error, body: any) => void): void;
    endExecutionPromise(request: EndExecutionRequest): Promise<void>;
    submitEvents(packetToSend: IEventsFile, callback: (err: Error, body: any) => void, async?: boolean): void;
    submitEventsPromise(packetToSend: IEventsFile): Promise<void>;
    submitBlobAsync(body: object, buildSessionId: string, blobId: string, blobType?: string): Promise<any>;
    submitBlob(body: object, buildSessionId: string, blobId: string, callback: (err: Error, body: any) => void): void;
    getBlobsAsJson<T = {
        [generatedUid: string]: string;
    }>(buildSessionId: string, blobType?: string): Promise<T[]>;
    getSlMappingFromServer(buildSessionId: string): Promise<Array<{
        [generatedUid: string]: string;
    }>>;
    submitAgentEvent<T>(body: IAgentEventRequest<T>): Promise<void>;
    getTestsRecommendation(buildSessionId: string, stage: string, testGroupId?: string): Promise<ITestsRecommendationResponse>;
    addOrUpdateIntegrationBuildComponents(buildSessionId: string, components: IIntegrationBuildDependency[], agentId: string): Promise<unknown>;
    deleteIntegrationBuildComponents(buildSessionId: string, components: IIntegrationBuildDependency[], agentId: string): Promise<unknown>;
    buildEnd(data: IBuildEndData): Promise<void>;
    submitFootprintsV6(footprintsPacket: IFootprintsV6File, executionBsid: string, testStage: string, buildSessionId: string): Promise<void>;
    submitFootprintsToCollector(footprintsPacket: IFootprintsV6File, buildSessionId: string): Promise<void>;
    getBuildSessionData(buildSessionId: string): Promise<BuildSessionData>;
    getRecommendedAgent(configuration?: any): Promise<{}>;
    getBuildSessionDataFromLabId(labid: string): Promise<BuildSessionData>;
    updateMetadata(metadata: Partial<SlAgentMetadata>): void;
    protected invokeCallback(callback: (err: Error, apiResponse: any) => void, err: Error, body: any, map?: (body: any) => any): void;
    private submitPostRequestWithRetries;
    private submitPutRequestWithRetries;
    private submitDelRequestWithRetries;
    private submitGetRequestWithRetries;
    private makeRequestWithRetries;
    private shouldRetryRequest;
    getSyncedTime(currentTime: number): Promise<IClockSyncResult>;
    submitNycCoverageMap(buildSessionId: string, map: NycCoverageMap): Promise<void>;
    submitNodeV8CoverageMap(buildSessionId: string, map: NodeV8CoverageMap): Promise<void>;
    submitRawCoverageMapEnd(buildSessionId: string): Promise<void>;
    submitNycRawCoverageHits(executionBsid: string, buildSessionId: string, testStage: string, hits: NycRawHitsPayload): Promise<void>;
    submitNodeV8RawCoverageHits(executionBsid: string, buildSessionId: string, testStage: string, hits: NodeV8RawHitsPayload): Promise<void>;
}
