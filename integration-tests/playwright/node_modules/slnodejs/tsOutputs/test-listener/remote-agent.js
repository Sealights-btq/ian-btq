"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteAgent = void 0;
const system_date_1 = require("../common/system-date");
const uuid_1 = require("./uuid");
const events_contracts_1 = require("../common/events-process/events-contracts");
const cockpit_notifier_1 = require("../common/agent-events/cockpit-notifier");
const agent_instance_data_1 = require("../cli-parse/agent-instance-data");
const remote_browser_hits_converter_1 = require("../common/footprints-process-v6/remote-browser-hits-converter");
const state_tracker_1 = require("../common/state-tracker");
const contracts_1 = require("../common/http/contracts");
/**
 *  Agent that dose not collects footprints by itself, the coverage collected from another agent (e.g browser)
 */
class RemoteAgent {
    constructor(agentConfig, logger, backendProxy, testRecommendationHandler, eventsProcess, footprintsProcess, httpMetricsProcess, hitsCollector, hitsConverter, stateTracker, collectorBackendProxy) {
        this.collectorBackendProxy = collectorBackendProxy;
        this._isStartingExecution = true;
        this._agentConfig = agentConfig;
        this.logger = logger;
        this.backendProxy = backendProxy;
        this.testRecommendationHandler = testRecommendationHandler;
        this.eventsProcess = eventsProcess;
        this.footprintsProcess = footprintsProcess;
        this.httpMetricsProcess = httpMetricsProcess;
        this.hitsCollector = hitsCollector;
        this.hitsConverter = hitsConverter;
        this.stateTracker = stateTracker;
        this.queriedBsids = {};
        this.logger.debug('RemoteAgent instance created with config:', this._agentConfig.toJsonObject());
    }
    start(args, slMapping) {
        return __awaiter(this, void 0, void 0, function* () {
            yield cockpit_notifier_1.CockpitNotifier.notifyStart(this._agentConfig, agent_instance_data_1.AgentInstanceDataFactory.getOrCreateAgentInstanceData(), this.logger, system_date_1.getSystemOffset, this.backendProxy, args === null || args === void 0 ? void 0 : args.packageJsonFile, args === null || args === void 0 ? void 0 : args.tool, args === null || args === void 0 ? void 0 : args.tags);
            if (this.hitsConverter instanceof remote_browser_hits_converter_1.RemoteBrowserHitsConverter && !slMapping) {
                this.hitsConverter.slMapping = yield this.getSlMapping(this._agentConfig.buildSessionId.value);
            }
            else if (slMapping) {
                this.setSlMapping(this._agentConfig.buildSessionId.value, slMapping);
            }
            // This code was added here because the createRemoteAgent method is not async at the moment and this initialization must be done prior to collecting coverage
            const instrumentationMethodology = yield this.getInstrumentationMethodology();
            this.footprintsProcess.updateInstrumentationMethodology(instrumentationMethodology);
            this.eventsProcess.start();
            this.footprintsProcess.start();
            this.httpMetricsProcess.start();
        });
    }
    // TODO: should not be in that class
    getSlMapping(bsid) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.queriedBsids[bsid]) {
                return this.hitsConverter.slMapping;
            }
            const mappingsArr = yield (this.collectorBackendProxy ? this.collectorBackendProxy.getBlobsAsJson(bsid) : this.backendProxy.getBlobsAsJson(bsid));
            let flatted = {};
            mappingsArr.forEach(mapping => {
                flatted = Object.assign(Object.assign({}, flatted), mapping);
            });
            this.queriedBsids[bsid] = true;
            return flatted;
        });
    }
    getInstrumentationMethodology() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { methodology } = yield this.backendProxy.getInstrumentationMethodology(this._agentConfig.buildSessionId.value);
                return methodology;
            }
            catch (e) {
                const errorMsg = `Failed to get instrumentation methodology, defaulting to Methods instrumentation methodology. Error: '${e}'`;
                this.logger.error(errorMsg);
                cockpit_notifier_1.CockpitNotifier.sendError(errorMsg);
                return contracts_1.InstrumentationMethodology.Methods;
            }
        });
    }
    // Can be used to set slMapping from outside, for example in case of Lambda layer which already has the slMapping in the config
    setSlMapping(bsid, slMapping) {
        return __awaiter(this, void 0, void 0, function* () {
            this.hitsConverter.slMapping = slMapping;
            this.queriedBsids[bsid] = true;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.eventsProcess.stop();
            yield this.footprintsProcess.stop();
            yield this.httpMetricsProcess.stop();
            yield this.endExecution();
            yield cockpit_notifier_1.CockpitNotifier.notifyShutdown();
        });
    }
    getExcludedTests() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.testRecommendationHandler.getExcludedTests();
        });
    }
    startExecution() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isStartingExecution) {
                return this.loadExecution();
            }
            if (this.executionId) {
                this.logger.warn(`Execution already created. New one won\`t be created`);
                return;
            }
            this.executionId = uuid_1.UUID.newGuid([(0, system_date_1.getSystemDateValueOf)().toString(), this._agentConfig.customerId.value].join());
            return this.stateTracker.startColoredExecution(this.executionId);
        });
    }
    loadExecution() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.stateTracker.loadExecutionSync();
            this.executionId = this.stateTracker.currentExecution.executionId;
        });
    }
    setExecution(executionData) {
        this.executionId = executionData.execution.executionId;
    }
    endExecution() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isStartingExecution) {
                return;
            }
            yield this.footprintsProcess.submitQueuedFootprints(this.stateTracker.currentExecution);
            const request = this.buildEndExecutionRequest();
            this.executionId = null;
            return this.backendProxy.endExecutionPromise(request);
        });
    }
    buildEndExecutionRequest() {
        return {
            isValidToken: true,
            proxy: this._agentConfig.proxy.value,
            server: this._agentConfig.server.value,
            appName: this._agentConfig.appName.value,
            branchName: this._agentConfig.branch.value,
            buildName: this._agentConfig.build.value,
            customerId: this._agentConfig.customerId.value,
            environment: this._agentConfig.labId.value || this._agentConfig.buildSessionId.value,
            executionIds: [this.executionId]
        };
    }
    testStart(testName, testSuiteName, timestamp) {
        this.stateTracker.setTestIdentifier(testName);
        this.eventsProcess.enqueueEvent({ type: events_contracts_1.EventTypes.TestStart, testName, suite: testSuiteName, executionId: this.executionId, localTime: timestamp });
    }
    testEnd(testName, testSuiteName, duration, result, coverage, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            this.hitsCollector.globalCoverageObject = coverage;
            this.eventsProcess.enqueueEvent({ type: events_contracts_1.EventTypes.TestEnd, testName, suite: testSuiteName, duration, result, executionId: this.executionId, localTime: timestamp });
            yield this.footprintsProcess.enqueueCurrentFootprints(this.getExecutionData(), testName);
        });
    }
    sendTestCoverage(testName, coverage) {
        return __awaiter(this, void 0, void 0, function* () {
            this.hitsCollector.globalCoverageObject = coverage;
            const executionData = this.getExecutionData();
            yield this.footprintsProcess.enqueueCurrentFootprints(executionData, testName);
            yield this.footprintsProcess.submitQueuedFootprints(executionData);
        });
    }
    sendComponentsTestCoverage(testName, components) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get sl-mapping for the components
            yield Promise.all(components.map((componentConfig) => __awaiter(this, void 0, void 0, function* () {
                const mapping = yield this.getSlMapping(componentConfig.buildSessionId);
                this.hitsConverter.slMapping = Object.assign(Object.assign({}, this.hitsConverter.getSlMapping()), mapping);
            })));
            // Submit the footprints per-component
            yield Promise.all(components.map((componentConfig) => __awaiter(this, void 0, void 0, function* () {
                this.hitsCollector.globalCoverageObject = componentConfig.coverage;
                const currentExecutionData = this.getExecutionData();
                yield this.footprintsProcess.enqueueCurrentFootprints(currentExecutionData, testName);
                yield this.footprintsProcess.submitComponentQueuedFootprints(componentConfig.buildSessionId, currentExecutionData.testStage);
            })));
        });
    }
    integTestEnd(testName, testSuiteName, duration, result, coverage, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(coverage.bsids.map((bsid) => __awaiter(this, void 0, void 0, function* () {
                const mapping = yield this.getSlMapping(bsid);
                this.hitsConverter.slMapping = Object.assign(Object.assign({}, this.hitsConverter.getSlMapping()), mapping);
            })));
            this.hitsCollector.globalCoverageObject = coverage.coverage;
            this.eventsProcess.enqueueEvent({ type: events_contracts_1.EventTypes.TestEnd, testName, suite: testSuiteName, duration, result, executionId: this.executionId, localTime: timestamp });
            yield this.footprintsProcess.enqueueCurrentFootprints(this.getExecutionData(), testName);
        });
    }
    getExecutionData() {
        return {
            executionId: this.executionId,
            buildSessionId: this.agentConfig.buildSessionId.value,
            testStage: this.agentConfig.testStage.value,
            appName: this.agentConfig.appName.value,
            branchName: this.agentConfig.branch.value,
            buildName: this.agentConfig.build.value,
            status: state_tracker_1.StateTracker.EXECUTION_STATUS_CREATED
        };
    }
    get agentConfig() {
        return this._agentConfig;
    }
    get isStartingExecution() {
        return this._isStartingExecution;
    }
    set isStartingExecution(value) {
        this._isStartingExecution = value;
    }
}
exports.RemoteAgent = RemoteAgent;
//# sourceMappingURL=remote-agent.js.map