import { Logger } from '../../common/contracts';
import { SourceMapsEraserModes } from '../source-map-eraser/interface';
import { ICockpitNotifierPiggyback } from '../../common/agent-events/cockpit-notifier';
export interface IFilesInstrumenterParams {
    sourceRoot: string;
    outputPath: string;
    extensionsToInstrument: Record<string, boolean>;
    buildSessionId: string;
    esModules: boolean;
    excludedPaths: string;
    useRelativeSlMapping: boolean;
    workspacePath: string;
    shouldMinifyInstrumentedOutput: boolean;
    reduceInstrumentedFileSize: boolean;
    omitInstrumentedFunctionMap: boolean;
    useBranchCoverage: boolean;
    babylonPlugins: boolean;
    excludeSourceMapFiles: SourceMapsEraserModes;
    experimentalSizeReduction: boolean;
    newInstrumenter: boolean;
    skipInstrumentingFilesWithoutSourceMap: boolean;
    toggleBasedBrowserInstrumentation: boolean;
}
export interface IFileInstrumentationResult {
    isInstrumented: boolean;
    isInstrumentationError: boolean;
    instrumentationErrorMessage: string;
    isCopied: boolean;
    isCopyError: boolean;
    copyErrorMessage: string;
    filename: string;
}
export declare class FilesInstrumenter {
    private params;
    private preambleHeader;
    private logger;
    private cockpitNotifier;
    private copyAsIsStrategy;
    private jsFileInstrumentationStrategy;
    private markupFileInstrumentationStrategy;
    private sourceMapsEraser;
    private ignoredFilesHandler;
    private ignoredInstrumentFilesHandler;
    private instrumenter;
    private excludeSourceMapFiles?;
    constructor(params: IFilesInstrumenterParams, preambleHeader: string[], logger: Logger, cockpitNotifier: ICockpitNotifierPiggyback);
    private createIgnoreHandler;
    processSingleFileAsync(filePath: any, skipInstrumentation?: boolean): Promise<IFileInstrumentationResult>;
    private getInputFile;
    private getOutputFile;
    private isFileAcceptedBySlIgnore;
}
