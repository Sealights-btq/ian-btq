"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodSignature = void 0;
const guess_method_location_1 = require("./guess-method-location");
const guess_method_name_1 = require("./guess-method-name");
const astUtils = require("sl-esprima-ast-utils");
const md5 = require("md5");
const generator_1 = require("@babel/generator");
const traverse = require("ast-traverse");
const ast_node_types_1 = require("./ast-node-types");
const utils = require("../utils");
const globalMethodIndexer = require("./globalMethodIndexer");
class MethodData {
    constructor(absoluteFilename, relativeFilename) {
        this.absoluteFilename = absoluteFilename;
        this.relativeFilename = relativeFilename;
        this.possiblePos = [];
        this.offsets = null;
        this.endOffset = null;
        this.endPosition = null;
        this.displayName = null;
        this.hash = null;
        this.sigHash = null;
        this.identifierPosition = null;
        this.accessibility = null;
    }
}
Object.defineProperty(MethodData.prototype, 'position', {
    enumerable: true,
    get: function position() {
        if (this.possiblePos.length) {
            return this.possiblePos[0].position;
        }
        return null;
    }
});
class TechSpecificInfo {
    static initFromAstNode(node) {
        var _a, _b, _c, _d, _e, _f, _g;
        const info = new TechSpecificInfo();
        info.isAsync = (_a = node.async) !== null && _a !== void 0 ? _a : false;
        info.isComputed = (_b = node.computed) !== null && _b !== void 0 ? _b : false;
        info.isExpression = (_c = node.expression) !== null && _c !== void 0 ? _c : false;
        info.isGenerator = (_d = node.generator) !== null && _d !== void 0 ? _d : false;
        info.kind = node.kind;
        info.isStatic = (_e = node.static) !== null && _e !== void 0 ? _e : false;
        info.isDecorated = (_g = ((_f = node.decorators) === null || _f === void 0 ? void 0 : _f.length) > 0) !== null && _g !== void 0 ? _g : false;
        return info;
    }
}
class MethodSignature {
    /**
     * Crates method object from node recived from ast
     * @constructor
     */
    constructor(node, parentNode, nodeToParent, absolutePath, relativePath, logger, allowAccessibilityAdjustment, includeNestedAnonymousMethodsIntoHash, enableLineCoverage = false, recognizeBabelCreateClass = false) {
        this.node = node;
        this.parentNode = parentNode;
        this.nodeToParent = nodeToParent;
        this.logger = logger;
        this.allowAccessibilityAdjustment = allowAccessibilityAdjustment;
        this.includeNestedAnonymousMethodsIntoHash = includeNestedAnonymousMethodsIntoHash;
        this.enableLineCoverage = enableLineCoverage;
        this.recognizeBabelCreateClass = recognizeBabelCreateClass;
        this.meta = {};
        this.type = null;
        this.shouldSkip = false;
        this.hasSourceData = false;
        this.techSpecificInfo = null;
        this.generatedData = null;
        this.srcData = null;
        this.idxInMapping = null;
        this.generatedData = new MethodData(absolutePath, relativePath);
        this.srcData = new MethodData();
        this.techSpecificInfo = TechSpecificInfo.initFromAstNode(node);
        this.idxInMapping = globalMethodIndexer.getCurrentIndex();
        this.enableLineCoverage = enableLineCoverage;
    }
    init() {
        const nameObject = (0, guess_method_name_1.guessMethodName)(this.node, this.parentNode);
        this.type = nameObject.type;
        this.generatedData.possiblePos = (0, guess_method_location_1.getPossibleMethodLocations)(this.node, this.nodeToParent, this.allowAccessibilityAdjustment, this.recognizeBabelCreateClass);
        this.generatedData.offsets = [this.node.start];
        this.generatedData.endOffset = this.node.end;
        this.generatedData.endPosition = MethodNodeUtil.positionToArray(this.node.loc.end);
        this.generatedData.identifierPosition = this.getIdentifierPosition();
        this.generatedData.hash = this.calculateHash();
        this.generatedData.sigHash = this.calculateSigHash();
        this.generatedData.displayName = nameObject.name;
        this.generatedData.accessibility = this.node.accessibility || null;
        this.meta.anonymous = nameObject.isAnonymous;
        this.meta.identifierPosition = this.getIdentifierPosition();
        this.techSpecificInfo.isAnonymous = nameObject.isAnonymous;
        // TODO: probably it is smarter to set srcData only when sourceMap is available and leave it as null in other cases
        this.srcData = utils.cloneObject(this.generatedData, this.logger);
    }
    calculateHash() {
        const clonedNode = astUtils.clone(this.node);
        // Visit node in pre order and calculate body hash.
        traverse(clonedNode, {
            pre: (node) => {
                // If current node is the root node given return (we want to calculate the body hash only).
                if (node == clonedNode)
                    return;
                if (ast_node_types_1.AstNodeTypes.isMethodNode(node)) {
                    const methodNode = node;
                    if (!this.includeNestedAnonymousMethodsIntoHash || !MethodNodeUtil.isAnonymous(methodNode)) {
                        MethodNodeUtil.emptyNode(methodNode);
                    }
                }
            }
        });
        const generatedCode = MethodNodeUtil.generateCodeFromAst(clonedNode);
        return md5(generatedCode);
    }
    calculateSigHash() {
        var _a;
        if (!((_a = this.node.params) === null || _a === void 0 ? void 0 : _a.length)) {
            return '';
        }
        const paramsStr = this.node.params.map(param => MethodNodeUtil.generateCodeFromAst(param)).join(',');
        return md5(paramsStr);
    }
    createUniqueId() {
        const relevantData = this.hasSourceData ? this.srcData : this.generatedData;
        const position = [...relevantData.position];
        return [relevantData.relativeFilename, position.join(',')].join('@');
    }
    getAccessibility() {
        const relevantData = this.hasSourceData ? this.srcData : this.generatedData;
        if (relevantData.accessibility) {
            return { accessibility: relevantData.accessibility };
        }
        return {};
    }
    createUniqueIdKeyForSlMapping() {
        return [this.generatedData.absoluteFilename, this.generatedData.position.join(',')].join('@');
    }
    countExecutableLines(methodNode) {
        const executableLineNumbers = new Set();
        // Traverse the AST recursively
        traverse(methodNode, {
            pre: (node) => {
                // Check if the node is executable
                if (ast_node_types_1.AstNodeTypes.isExecutableNode(node)) {
                    // Get the starting line for this node and add it to the set
                    executableLineNumbers.add(node.loc.start.line);
                }
            },
        });
        // The total number of executable lines
        return executableLineNumbers.size;
    }
    createDTO() {
        return Object.assign(Object.assign({ meta: this.meta, techSpecificInfo: this.techSpecificInfo, type: this.type, srcData: this.srcData, generatedData: this.generatedData, uniqueId: this.createUniqueId(), offsets: this.generatedData.offsets, endOffset: this.generatedData.endOffset, idxInMapping: this.idxInMapping, uniqueIdKey: this.createUniqueIdKeyForSlMapping() }, this.getAccessibility()), (this.enableLineCoverage && { executableLinesCount: this.countExecutableLines(this.node) }));
    }
    static create(node, parentNode, nodeToParent, absolutePath, relativePath, logger, allowAccessibilityAdjustment, hashIncludeNestedMethods, enableLineCoverage = false, recognizeBabelCreateClass = false) {
        const signature = new MethodSignature(node, parentNode, nodeToParent, absolutePath, relativePath, logger, allowAccessibilityAdjustment, hashIncludeNestedMethods, enableLineCoverage, recognizeBabelCreateClass);
        signature.init();
        return signature;
    }
    getIdentifierPosition() {
        const identifier = this.node.id || this.node.key;
        if (identifier) {
            // according to @babel/types Identifier or Expresion can't have property position
            // there is no types for ast-traverse so lets relay on this logic
            const position = identifier.position || identifier.loc;
            if (position === null || position === void 0 ? void 0 : position.end) {
                return MethodNodeUtil.positionToArray(position.end);
            }
        }
        return [];
    }
}
exports.MethodSignature = MethodSignature;
class MethodNodeUtil {
    /**
     * @param node - modified by link
     */
    static emptyNode(node) {
        node.body = {
            type: ast_node_types_1.AstNodeTypesEnum.BlockStatement,
            body: [],
        };
        node.params = [];
        node.id = {
            name: '_',
            type: ast_node_types_1.AstNodeTypesEnum.Identifier,
        };
    }
    static generateCodeFromAst(node) {
        return (0, generator_1.default)(node, {
            comments: false
        }, '').code;
    }
    static positionToArray(loc) {
        return [loc.line, loc.column];
    }
    static isAnonymous(node) {
        var _a, _b;
        const actualName = ((_a = node.id) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.key) === null || _b === void 0 ? void 0 : _b.name);
        return !actualName;
    }
}
//# sourceMappingURL=method-signature.js.map