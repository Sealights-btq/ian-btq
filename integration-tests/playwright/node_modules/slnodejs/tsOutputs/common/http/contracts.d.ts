/// <reference types="node" />
/// <reference types="node" />
import { FindPosition, MappedPosition } from 'source-map';
import { AgentTechnologies, AgentTypes } from '../agent-events/agent-events-contracts';
import { NetworkInterfaceInfo } from 'os';
import { ICommitLog, ICommitLogWithContributorRef, IContributorData } from '../scm/contracts';
export declare class IHttpClientConfigData {
    token?: string;
    proxy: string;
    server: string;
    buildSessionId?: string;
    defaultTimeout?: number;
    compressRequests?: boolean;
    labId?: string;
    appName?: string;
    branchName?: string;
    buildName?: string;
    testProjectId?: string;
    targetTestProjectId?: string;
}
export interface IBackendProxyConfig extends IHttpClientConfigData {
    httpMaxAttemps?: number;
    httpAttemptInterval?: number;
}
export declare class SlAgentMetadata {
    labId?: string;
    appName?: string;
    branchName?: string;
    buildName?: string;
    executionId?: string;
    agentId?: string;
    buildSessionId?: string;
    agentType?: AgentTypes;
    agentTechnology?: AgentTechnologies;
    messageType?: string;
    agentVersion?: string;
    testProjectId?: string;
    targetTestProjectId?: string;
}
export interface BuildSessionData {
    appName: string;
    buildName: string;
    branchName: string;
    buildSessionId: string;
    additionalArguments?: string;
}
export declare class CreateBuildSessionIdResponse {
    buildSessionId: string;
}
export interface IPullRequestParams {
    repositoryUrl: string;
    pullRequestNumber: number;
    latestCommit: string;
    targetBranch: string;
}
export interface PullRequestConfigData extends BuildSessionData {
    pullRequestParams: IPullRequestParams;
}
export declare class GetVersionRequest {
    customerId: string;
    appName: string;
    testStage: string;
    branchName: string;
    componentName: string;
    buildName: string;
}
export declare class GetVersionResponse {
    agent: AgentInfo;
    meta: VersionMeta;
}
export declare class AgentInfo {
    date: number;
    name: string;
    url: string;
    version: string;
}
export declare class VersionMeta {
    generated: number;
    requestUrl: string;
    query: VersionMetaQuery;
}
export declare class VersionMetaQuery {
    agentType: string;
    isDefault: boolean;
}
export interface IBuildMapMetaEnvironment {
    agentVersion: string;
    agentType: 'nodeJsBuildScanner';
    processArgv: string[];
    machineName: string;
    platform: string;
    os: string;
    osVersion: string;
    arch: string;
    processId: number;
    ipAddress: Record<string, NetworkInterfaceInfo[]>;
    dependencies: NodeJS.ProcessVersions;
    runtime: string;
}
export interface IBuildMapMeta {
    generated: number;
    build: string;
    commit: string;
    agentId: string;
    customerId: string;
    appName: string;
    technology: string;
    branch: string;
    environment: IBuildMapMetaEnvironment;
    authors: string;
    logsUrl: string;
    jobName: string;
    moduleName: string;
    uniqueModuleId: string;
    configurationData: Record<string, unknown>;
    scm: string;
    scmProvider: string;
    scmVersion: string;
    scmBaseUrl: string;
    buildSessionId: string;
    history: string[];
    commitLog: (ICommitLog | ICommitLogWithContributorRef)[];
    repositoryUrl: string;
    contributors: IContributorData[];
    additionalGitDetails: {
        currentBranch: string;
        openBranches: string[];
        submodules: string[];
    };
}
export interface IBuildMapChunkMeta extends IBuildMapMeta {
    partId: number;
}
export declare class BuildMappingRequest {
    meta: IBuildMapMeta;
    files: FileData[];
    dependencies: DependencyData[];
    version: string;
    includedFiles: string[];
    counters: {
        methods: number;
        branches: number;
    };
}
export declare class BuildMappingChunkRequest extends BuildMappingRequest {
    meta: IBuildMapChunkMeta;
}
export interface IBuildMapEndRequest {
    agentId: string;
    status: {
        success: boolean;
        message: string;
        duration: number;
    };
    labId: string;
    partsCount: number;
}
export interface IDryRunBuildMappingRequest extends BuildMappingRequest {
    excludedFiles: string[];
}
export interface IDryRunBuildMappingChunkRequest extends BuildMappingChunkRequest {
    excludedFiles: string[];
}
export declare class DependencyData {
    appName: string;
    branch: string;
    build: string;
}
export declare class FileData {
    logicalPath: string;
    physicalPath: string;
    transpiledFile: string;
    methods: MethodInfo[];
    branches: any[];
    lines: any[];
    hash: string;
    absolutePath?: string;
    fromSourceMaps?: boolean;
    positionToMethod: {
        [key: string]: number;
    };
    positionToBranch: {
        [key: string]: number;
    };
    endPositionToMethod?: {
        [key: string]: number;
    };
    commitIndexes?: number[];
}
export interface ISourceMapConsumer {
    originalPositionFor(generatedPosition: FindPosition): MappedPosition;
}
export interface MappingResult {
    fileName: string;
    methods: MethodInfo[];
    branches?: BranchInfo[];
}
export interface BranchInfo extends CodeItem {
    filename: string;
    type: string;
    endPosition: number[];
    hash: string;
    index: number;
    parentPosition: number[];
    enclosingMethodIdx: number;
}
export interface CodeItem {
    position: number[];
    techSpecificInfo: TechSpecificInfo;
    meta?: Meta;
    uniqueId?: string;
    uniqueIdKey?: string;
}
export interface MethodInfo extends CodeItem {
    endPosition: number[];
    displayName: string;
    hash: string;
    sigHash: string;
    idxInMapping: number;
    oldHash?: string;
    oldSigHash?: string;
    offsets: number[];
    endOffset: number;
}
export interface Meta {
    anonymous: boolean;
    identifierPosition?: number[];
}
export interface TechSpecificInfo {
    isAsync: boolean;
    isComputed: boolean;
    isExpression: boolean;
    isGenerator: boolean;
    isStatic: boolean;
    isAnonymous: boolean;
    autoGenerated?: boolean;
    isDecorated?: boolean;
}
export interface GeneratedData {
    position: number[];
    endPosition: number[];
    displayName: string;
    hash: string;
    sigHash: string;
    relativeFilename: string;
    absoluteFilename: string;
    identifierPosition: any[];
}
export interface SignatureMethod {
    meta: Meta;
    techSpecificInfo: TechSpecificInfo;
    type?: any;
    srcData: GeneratedData;
    generatedData: GeneratedData;
    uniqueId: string;
    idxInMapping: number;
    uniqueIdKey: string;
}
export declare class GetRemoteConfigRequest {
    appName?: string;
    branch?: string;
    build?: string;
    testStage?: string;
    labId?: string;
}
export declare class SubmitLogsRequest {
    appName: string;
    customerId: string;
    environment: EnvironmentData;
    log: string[];
    start?: number;
    end?: number;
}
export declare class IMetricsBatch {
    start: number;
    end: number;
    metrics: IMetric[];
}
export type MetricType = 'increment' | 'histogram' | 'gauge';
export interface IMetric {
    name: string;
    type: MetricType;
    value: string | number;
    tags: Record<string, string>;
    timestamp: number;
}
export declare class BaseRequest {
    customerId: string;
    appName: string;
    server: string;
    proxy: string;
    isValidToken: boolean;
}
export declare class StartExecutionRequest extends BaseRequest {
    testStage: string;
    source?: string;
    testGroupId?: string;
    labId: string;
    buildName: string;
    branchName: string;
    newEnvironment: string;
    environment: string;
}
export declare class EndExecutionRequest extends BaseRequest {
    environment: string;
    buildName: string;
    branchName: string;
    executionIds?: string[];
}
export declare class UploadReportRequest extends BaseRequest {
    environmentName: string;
    reportFile: string[];
    reportFilesFolder: string[];
    labId: string;
    build: string;
    branch: string;
    source: string;
    type: string;
    hasMoreRequests: boolean;
}
export declare class AgentData {
    customerId: string;
    appName: string;
    type: string;
    source: string;
    hasMoreRequests: boolean;
    buildName?: string;
    branchName?: string;
    environment: EnvironmentData;
}
export declare class EnvironmentData {
    labId: string;
    environmentName: string;
}
export declare class UploadReportsBody {
    agentData: AgentData;
    reportFile: any;
}
export interface IHttpClient {
    get<T>(urlPath: string, callback: (err: Error, response: T, statusCode: number) => void, isNotFoundAcceptable?: boolean, async?: boolean): any;
    delete<T>(body: any, urlPath: string, callback: (err: Error, data: T, statusCode: number) => void): any;
    put(requestData: any, urlPath: string, callback: (err: Error, body: any, statusCode: number) => void, async?: boolean, contentType?: string): any;
    post(requestData: any, urlPath: string, callback: (err: Error, body: any, statusCode: number) => void, async?: boolean, contentType?: ContentType): any;
    postMultipart(requestData: any, urlPath: string, callback: (err: Error, body: any, statusCode: number) => void): any;
    updateMetadata(metadata: Partial<SlAgentMetadata>): void;
}
export interface ITestsRecommendationResponse {
    excludedTests: IExcludedTest[];
    recommendationSetStatus: RecommendationSetStatus;
    testSelectionEnabled: boolean;
}
export interface IExcludedTest {
    name: string;
    universalTestId: string;
    testFramework: string;
}
export declare enum RecommendedTestReason {
    PINNED = "pinned",
    IMPACTED = "impacted",
    FAILED = "failed"
}
export declare enum RecommendationSetStatus {
    NOT_READY = "notReady",
    READY = "ready",
    NO_HISTORY = "noHistory",
    ERROR = "error",
    WONT_BE_READY = "wontBeReady"
}
export interface IBuildEndData {
    appName: string;
    build: string;
    branch: string;
    status: IBuildEndStatus;
}
export interface IBuildEndStatus {
    success: boolean;
}
export declare enum ContentType {
    OCTET_STREAM = "application/octet-stream",
    JSON = "application/json"
}
export declare enum SealightsHeaderNames {
    CONTENT_TYPE = "Content-Type",
    AUTHOTIZARTION = "Authorization",
    MODE = "X-Sealights-Agent-Mode",
    META_DATA = "sl-metadata",
    LAB_ID = "x-sl-labId",
    APP_NAME = "x-sl-appName",
    BRANCH_NAME = "x-sl-branchName",
    BUILD_NAME = "x-sl-buildName",
    BSID = "x-sl-bsid",
    EXECUTION_ID = "x-sl-executionId",
    AGENT_ID = "x-sl-agentId",
    MESSAGE_TYPE = "x-sl-messageType",
    TEST_PROJECT_ID = "x-sl-testProjectId",
    TARGET_TEST_PROJECT_ID = "x-sl-targetTestProjectId"
}
export declare enum SealightsHaderValues {
    LIGHT_AGENT_MODE = "light"
}
export interface IColoredExecutionRequest {
    executionId: string;
    appName: string;
    buildName: string;
    branchName: string;
    labId: string;
    testStage: string;
    testGroupId?: string;
}
export interface IBuildSessionResponse {
    customerId: string;
    appName: string;
    branchName: string;
    buildName: string;
    buildSessionType: string;
    created: number;
    trackingId: string;
    additionalParams: object;
    buildSessionId: string;
}
export type NodeV8CoverageMap = Record<string, string>;
export type NodeV8RawHitsPayload = NodeV8Execution[];
export interface NodeV8Execution {
    executionId: string;
    hits: NodeV8Hit[];
}
export interface NodeV8Hit {
    start: number;
    end: number;
    isInitFootprints: boolean;
    testName?: string;
    methods: string[];
}
export type NycCoverageMap = unknown;
export type NycRawHitsPayload = NycExecution;
export interface NycExecution {
    executionId: string;
    hits: NycHits[];
}
export interface NycHitMeta {
    start: number;
    end: number;
    isInitFootprints: boolean;
    testName?: string;
}
export interface NycHits {
    metadata: NycHitMeta;
    counters: {
        [filename: string]: NycCounters;
    };
}
export interface NycCounters {
    b: Record<string, number[]>;
    f: Record<string, number>;
    s: Record<string, number>;
}
export declare enum InstrumentationMethodology {
    Methods = "Methods",
    MethodLines = "MethodLines"
}
export interface BuildMappingSubmitted {
    submitted: boolean;
}
