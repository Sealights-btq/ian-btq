"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DryRunProxy = void 0;
/**
 * Saves the requests sent to the backend, used for dryRun mode
 */
class DryRunProxy {
    constructor() {
        this._buildMappingRequestParts = [];
        this._agentEvents = [];
    }
    checkIfBuildMappingIsSubmitted(buildSessionId) {
        return Promise.resolve({ submitted: false });
    }
    submitFootprintsToCollector(_footprintsPacket, _buildSessionId) {
        return Promise.resolve();
    }
    endExecutionPromise(_request) {
        return Promise.resolve();
    }
    getBlobsAsJson(_buildSessionId) {
        return Promise.resolve(undefined);
    }
    submitBlob(body, buildSessionId, blobId, callback) {
        if (blobId === 'sl-mapping') {
            this._slMapping = body;
        }
        return callback(null, null);
    }
    submitBlobAsync(body, buildSessionId, blobId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (blobId === 'sl-mapping') {
                this._slMapping = body;
            }
        });
    }
    submitBuildMapping(request) {
        this._buildMappingRequest = request;
        return Promise.resolve(undefined);
    }
    submitPartialBuildMapping(request) {
        this._buildMappingRequestParts.push(request);
        if (!this._buildMappingRequest) {
            this._buildMappingRequest = request;
        }
        else {
            this._buildMappingRequest.files.push(...request.files);
        }
        return Promise.resolve(undefined);
    }
    submitBuildMappingEnd(_request, _buildSessionId) {
        return Promise.resolve(undefined);
    }
    updateMetadata(metadata) { }
    addOrUpdateIntegrationBuildComponents(buildSessionId, components, agentId) {
        return Promise.resolve(undefined);
    }
    buildEnd(data) {
        return Promise.resolve(undefined);
    }
    createBuildSessionId(request, callback) {
    }
    createBuildSessionIdPromise(request) {
        return Promise.resolve('');
    }
    deleteIntegrationBuildComponents(buildSessionId, components, agentId) {
        return Promise.resolve(undefined);
    }
    getInstrumentationMethodology(buildSessionId) {
        return Promise.resolve(undefined);
    }
    endExecution(request, callback) {
    }
    externalReport(request, callback) {
    }
    getBuildSession(buildSessionId, callback) {
    }
    getBuildSessionData(buildSessionId) {
        return Promise.resolve(undefined);
    }
    getBuildSessionDataFromLabId(labid) {
        return Promise.resolve(undefined);
    }
    getRecommendedAgent(configuration) {
        return Promise.resolve({});
    }
    getRecommendedVersion(request) {
        return Promise.resolve(undefined);
    }
    getRemoteConfig(request, callback) {
    }
    getRemoteConfigPromise(request) {
        return Promise.resolve(undefined);
    }
    getTestsRecommendation(buildSessionId, stage) {
        return Promise.resolve(undefined);
    }
    startColoredExecution(request) {
        return Promise.resolve(undefined);
    }
    startExecution(request, callback) {
    }
    submitAgentEvent(body) {
        this.agentEvents.push(body);
        return Promise.resolve(undefined);
    }
    submitEvents(packetToSend, callback, async) {
    }
    submitEventsPromise(packetToSend) {
        return Promise.resolve(undefined);
    }
    submitFootprintsV6(footprintsPacket, executionBsid, testStage, buildSessionId) {
        return Promise.resolve(undefined);
    }
    submitLogs(request) {
        return Promise.resolve(undefined);
    }
    submitAgentMetrics(_request) {
        return Promise.resolve(undefined);
    }
    testExecutionV4(labId, async, executionId) {
        return Promise.resolve(undefined);
    }
    uploadReport(request, callback) {
    }
    submitNycCoverageMap(buildSessionId, map) {
        throw new Error('Method not implemented.');
    }
    submitNodeV8CoverageMap(buildSessionId, map) {
        this._nodeV8CoverageMap = map;
        return Promise.resolve(undefined);
    }
    submitRawCoverageMapEnd(buildSessionId) {
        return Promise.resolve(undefined);
    }
    submitNycRawCoverageHits(executionBsid, buildSessionId, testStage, hits) {
        throw new Error('Method not implemented.');
    }
    submitNodeV8RawCoverageHits(executionBsid, buildSessionId, testStage, hits) {
        return Promise.resolve(undefined);
    }
    getSyncedTime(currentTime) {
        return Promise.resolve(undefined);
    }
    get buildMappingRequest() {
        return this._buildMappingRequest;
    }
    get partialBuildMappingRequest() {
        return this._buildMappingRequestParts;
    }
    get slMapping() {
        return this._slMapping;
    }
    get nodeV8CoverageMap() {
        return this._nodeV8CoverageMap;
    }
    get agentEvents() {
        return this._agentEvents;
    }
}
exports.DryRunProxy = DryRunProxy;
//# sourceMappingURL=dry-run-proxy.js.map