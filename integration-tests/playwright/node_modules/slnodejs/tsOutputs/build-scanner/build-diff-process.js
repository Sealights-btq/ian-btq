"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildDiffProcess = exports.shouldSubmitSlMapping = void 0;
const fs = require("fs");
const path = require("path");
const os = require("os");
const scm_files_container_1 = require("./scm/scm-files-container");
const files_container_1 = require("./mappings/files-container");
const sl_mapper_1 = require("./js_diff/sl-mapper");
const file_path_fixer_1 = require("./mappings/file-path-fixer");
const scm_file_fixer_1 = require("./scm/scm-file-fixer");
const cockpit_notifier_1 = require("../common/agent-events/cockpit-notifier");
const factory_1 = require("./source-map-eraser/factory");
// not updated cjs modules
const FilesMapping = require("./js_diff/files-mapping");
const EnsureFilesHandlerServiceModule = require("./mappings/ensure-files-handler.service");
const DryRunFilesMapping = require("./js_diff/dry-run-files-mapping");
const utils = require("./utils.js");
const DefaultValuesResolver = require("./default-values-resolver");
const fileAndFolderUtils = require("./file-and-folder-utils");
const BrowserInstrumenter = require("./instrumentation/browser-instrumenter");
const SlEnvModule = require("../common/constants/sl-env-vars");
const contracts_1 = require("./diagnostic/contracts");
const system_date_1 = require("../common/system-date");
const sl_mapper_tokenizer_1 = require("../common/sl-mapper-tokenizer");
// TODO: Find a way to get version number without relative path
// var version = require("../package.json").version;
const version = '1.0.0';
const { EnsureFilesHandlerService } = EnsureFilesHandlerServiceModule;
const CiaEnvVars = SlEnvModule.SlEnvVars.CIA;
const dvr = new DefaultValuesResolver();
function shouldSubmitSlMapping(buildArguments) {
    if (!buildArguments.instrumentationOnly) {
        return true;
    }
    return !buildArguments.useRelativeSlMapping;
}
exports.shouldSubmitSlMapping = shouldSubmitSlMapping;
function shouldSubmitNodeV8RawCoverageSlMapper(buildArguments) {
    return buildArguments.rawCoverage;
}
function shouldCreateSlMapperTokenizer(buildArguments) {
    return buildArguments.compressSlMapping || CiaEnvVars.compressSlMapping();
}
function resolveSlMapperInstance(buildArguments, outputPath, backendProxy, logger) {
    const slMapperTokenizer = shouldCreateSlMapperTokenizer(buildArguments) ? new sl_mapper_tokenizer_1.SlMapperTokenizer() : null;
    if (buildArguments.useRelativeSlMapping || buildArguments.instrumentForBrowsers) {
        return new sl_mapper_1.BrowserSlMapper(outputPath, backendProxy, buildArguments.buildSessionId, logger, slMapperTokenizer);
    }
    return new sl_mapper_1.SlMapper(outputPath, backendProxy, buildArguments.buildSessionId, logger, slMapperTokenizer);
}
function resolveFilePathFixer(handlerParams, buildArguments, slMapper, nodeV8RawCoverageSlMapper, logger) {
    if (buildArguments.scm === 'git') {
        return new scm_file_fixer_1.ScmFileFixer(handlerParams.filesContainer, slMapper, nodeV8RawCoverageSlMapper, logger, handlerParams.projectRoot, handlerParams.scmRootDir, buildArguments.useModulePrefix, buildArguments.uniqueModuleId, buildArguments.rawCoverage, buildArguments.embedCorrectUniqueId);
    }
    else {
        return new file_path_fixer_1.FilePathFixer(handlerParams.filesContainer, slMapper, nodeV8RawCoverageSlMapper, logger, handlerParams.projectRoot, buildArguments.useModulePrefix, buildArguments.uniqueModuleId, buildArguments.rawCoverage, buildArguments.embedCorrectUniqueId);
    }
}
// TODO: should be moved to ConfigLoader when it will exist in context of scan
function checkDeprecatedEnvVar(logger) {
    const deprecatedEnvVars = [
        {
            key: 'SL_scmPrefix',
            message: 'Support of `SL_scmPrefix` param was removed in v6.1.515. Please contact customer.success@sealights.io if you have any scan issue. You might have an issue with how you use `--projectRoot`.'
        },
        {
            key: 'SL_HttpMaxAttempts',
            message: 'Please use `SL_httpMaxAttempts` instead'
        },
        {
            key: 'SL_HttpAttemptInterval',
            message: 'Please use `SL_httpAttemptInterval` instead'
        },
    ];
    for (const deprecatedEnvVar of deprecatedEnvVars) {
        if (process.env[deprecatedEnvVar.key]) {
            logger.warn(`Deprecated env_var \`${deprecatedEnvVar.key}\` was provided. ${deprecatedEnvVar.message}`);
            cockpit_notifier_1.CockpitNotifier.sendWarning(`Deprecated env_var \`${deprecatedEnvVar.key}\` was provided with value - '${process.env[deprecatedEnvVar.key]}'. ${deprecatedEnvVar.message}`);
        }
    }
}
// TODO: buildArgs not in use
function BuildDiffProcess(backendProxy, scmFactory, parsedDependencies, logger, diagnostic) {
    const childLogger = logger.child({
        className: 'BuildDiffProcess'
    });
    function createBuildDiffPromiseChain(buildArguments) {
        parsedDependencies = parsedDependencies || [];
        const handlerParams = {
            buildArguments: buildArguments,
            cfg: buildArguments,
            finalOutput: {
                meta: createMetaTag(buildArguments),
                version: '2.0',
                files: [],
                dependencies: parsedDependencies,
                includedFiles: [],
                counters: {
                    methods: 0,
                    branches: 0,
                }
            },
            processedFiles: null,
            fileToCommitsMap: null,
            scmRootDir: null,
            filesContainer: null,
            projectRoot: null,
            filePathFixer: null,
            commitToIndexMap: {},
            emailToIndexMap: {},
        };
        let promiseChain = Promise.resolve();
        // TODO: should be moved to ConfigLoader when it will exist
        checkDeprecatedEnvVar(childLogger);
        // verify buildSessionId is not already utilized
        // skip if multi-stage build with uniqueModuleId is used, as we don't have api to correctly verify it
        if (!buildArguments.isDryRunMode && !buildArguments.uniqueModuleId) {
            promiseChain = promiseChain.then(() => __awaiter(this, void 0, void 0, function* () {
                const response = yield backendProxy.checkIfBuildMappingIsSubmitted(buildArguments.buildSessionId);
                if (response.submitted) {
                    throw new Error(`Scan for buildSessionId "${buildArguments.buildSessionId}" was already performed.`);
                }
            }));
        }
        if (parsedDependencies.length == 0) { //If there are dependencies, no need to require workspacepath, scm, commit, and no need to perform actual scanning
            let scmInstance;
            if (buildArguments.workspacepath) {
                scmInstance = scmFactory.createScmByType(buildArguments.scm, buildArguments);
                if (scmInstance) {
                    handlerParams.finalOutput.meta.scm = buildArguments.scm;
                    childLogger.info(`Created an scmInstance of type '${buildArguments.scm}'. Searching for a local repository at '${buildArguments.workspacepath}'.`);
                    if (!buildArguments.commit && !scmInstance.detectCommitVersion) {
                        return Promise.reject(`'commit' command-line argument is required, since automatic detection by the '${buildArguments.scm}' SCM is not supported`);
                    }
                }
                else {
                    childLogger.warn(`Unsupported scm type: '${buildArguments.scm}'.`);
                }
                //2. If there is a mapping, get the diffs
                if (scmInstance) {
                    promiseChain = promiseChain.then(() => collectScmData(buildArguments, handlerParams, scmInstance));
                }
                promiseChain = promiseChain.then(function () {
                    const FileMappingInstance = buildArguments.isDryRunMode ? DryRunFilesMapping : FilesMapping;
                    const filesMapping = new FileMappingInstance(handlerParams, diagnostic, childLogger, handlerParams.projectRoot);
                    return filesMapping.process();
                });
            }
        }
        //4. Submit the final output to the server
        let slMapper = null;
        let nodeV8RawCoverageSlMapper = null;
        promiseChain = promiseChain.then(function () {
            slMapper = resolveSlMapperInstance(buildArguments, CiaEnvVars.getSlMappingPath(), backendProxy, childLogger);
            nodeV8RawCoverageSlMapper = new sl_mapper_1.NodeV8RawCoverageSlMapper(CiaEnvVars.getSlMappingPath(), backendProxy, buildArguments.buildSessionId, childLogger);
            handlerParams.filePathFixer = resolveFilePathFixer(handlerParams, buildArguments, slMapper, nodeV8RawCoverageSlMapper, childLogger);
            const fixer = new EnsureFilesHandlerService(childLogger, handlerParams.buildArguments, handlerParams.filesContainer, handlerParams.filePathFixer, handlerParams.scmRootDir, handlerParams.cfg, handlerParams.fileToCommitsMap, diagnostic);
            const result = fixer.ensureProcess(handlerParams.finalOutput);
            handlerParams.finalOutput = result.output;
            if (buildArguments.awsConfigure) {
                // Write the files from the final output to the disk so they can be retrieved for the AWS config file, also add sl-mapping data (for TS projects)
                const filePaths = result.output.files.map(file => file.logicalPath);
                const slMapping = slMapper.toJSON();
                fs.writeFileSync(process.cwd() + '/project-files.json', JSON.stringify({
                    files: filePaths,
                    slMapping: slMapping
                }, null, 2));
            }
            if (buildArguments.instrumentationOnly) {
                childLogger.info('No need to submit the files to server as the \'instrumentationOnly\' flag is on.');
                return Promise.resolve();
            }
            else {
                //TODO: [SLDEV-4708] When the call to the server fails, the agent is "silent" and not showing any error message.
                return submitBuildMapping(buildArguments, handlerParams.finalOutput);
            }
        });
        //5. Print the counters
        promiseChain = promiseChain.then(function () {
            const mapping = handlerParams.finalOutput;
            const counters = countElements(mapping.files);
            if (!buildArguments.isDryRunMode) {
                childLogger.lifecycle(`Scanned ${counters.methods} methods and ${counters.branches} branches in ${counters.files} files.`);
            }
        });
        if (shouldSubmitSlMapping(buildArguments)) {
            promiseChain = promiseChain.then(function () {
                return slMapper.submitMapping(buildArguments.uniqueModuleId);
            });
        }
        if (shouldSubmitNodeV8RawCoverageSlMapper(buildArguments)) {
            promiseChain = promiseChain.then(function () {
                return nodeV8RawCoverageSlMapper.submitMapping();
            });
        }
        promiseChain = promiseChain.then(function () {
            return diagnostic.submitDiagnostic();
        });
        promiseChain = promiseChain.then(function () {
            return uploadBuildMetadata(buildArguments);
        });
        // delete source maps if required
        if (buildArguments.excludeSourceMapFiles) {
            const sourceMapsEraser = factory_1.SourceMapEraserFactory.createSourceMapEraserByMode(buildArguments.excludeSourceMapFiles, childLogger, buildArguments.workspacepath);
            promiseChain = promiseChain.then(function () {
                return sourceMapsEraser.remove();
            });
        }
        //6. Create instrumented browser files.
        if (buildArguments.instrumentForBrowsers) {
            promiseChain = promiseChain.then(function () {
                if (handlerParams.finalOutput && handlerParams.finalOutput.files && !buildArguments.isDryRunMode) {
                    delete handlerParams.finalOutput.files;
                }
                const resolveWithoutHash = true;
                const delayShutdownInSeconds = buildArguments.delayShutdownInSeconds || 30;
                // TODO - is there any reason not to copy buildArguments as is an override specific fields which require logic?
                const instrumentationConfig = {
                    appName: buildArguments.appname,
                    build: buildArguments.build,
                    customerId: buildArguments.customerId,
                    branch: buildArguments.branch,
                    sourceRoot: buildArguments.workspacepath,
                    files: getProcessedFiles(buildArguments.workspacepath, childLogger),
                    outputPath: buildArguments.outputpath,
                    copyAllFilesToOutput: true,
                    buildSessionId: buildArguments.buildSessionId,
                    esModules: buildArguments['es6Modules'],
                    server: buildArguments.server,
                    overrideServer: buildArguments.overrideServer,
                    token: buildArguments.token,
                    instrumentationType: 'browser',
                    resolveWithoutHash: resolveWithoutHash,
                    delayShutdownInSeconds: delayShutdownInSeconds,
                    workspacepath: buildArguments.workspacepath,
                    slMappingPath: CiaEnvVars.getSlMappingPath(),
                    slMappingUrl: CiaEnvVars.getSlMappingUrl() || CiaEnvVars.getSlMappingPath(),
                    labId: buildArguments.labid,
                    collectorUrl: buildArguments.collectorUrl,
                    babylonPlugins: buildArguments.babylonPlugins,
                    usebranchcoverage: buildArguments.usebranchcoverage,
                    useRelativeSlMapping: buildArguments.useRelativeSlMapping,
                    enableOpenTelemetry: buildArguments.enableOpenTelemetry,
                    allowCORS: buildArguments.allowCORS,
                    footprintsMapping: buildArguments.footprintsMapping,
                    removeSensitiveData: buildArguments.removeSensitiveData,
                    excludeSourceMapFiles: buildArguments.excludeSourceMapFiles,
                    experimentalSizeReduction: buildArguments.experimentalSizeReduction,
                    splitPreambleIntoFile: buildArguments.splitPreambleIntoFile,
                    preambleFileName: buildArguments.preambleFileName,
                    preambleFileUrl: buildArguments.preambleFileUrl,
                    newInstrumenter: buildArguments.newInstrumenter,
                    excludeTokenFromBrowserConfig: buildArguments.excludeTokenFromBrowserConfig,
                    compressSlMapping: buildArguments.compressSlMapping || CiaEnvVars.compressSlMapping(),
                    ctxPropagationOnly: buildArguments.ctxPropagationOnly,
                    embedCorrectUniqueId: buildArguments.embedCorrectUniqueId,
                    reduceInstrumentedFileSize: buildArguments.reduceInstrumentedFileSize,
                    toggleBasedBrowserInstrumentation: buildArguments.toggleBasedBrowserInstrumentation,
                    allowedDomains: buildArguments.allowedDomains,
                };
                childLogger.info(`'instrumentForBrowsers' flag is on. Starting instrumentation. Instrumentation config: ${instrumentationConfig}`);
                const promise = runBrowserInstrumentation(childLogger, instrumentationConfig, slMapper);
                if (!buildArguments.isDryRunMode) {
                    return promise.then(_ => void 0);
                }
                return promise;
            });
        }
        return promiseChain;
    }
    function collectScmData(buildArguments, handlerParams, scmInstance) {
        let promiseChain = Promise.resolve();
        //2.1 Get repository url from the SCM
        promiseChain = promiseChain.then(function () {
            childLogger.info('Getting repository URL.');
            return getRepositoryUrl(handlerParams, scmInstance);
        });
        //2.2 Get all contributors from the scm
        if (buildArguments.sendContributors) {
            promiseChain = promiseChain.then(function () {
                childLogger.info('Getting contributors.');
                return getContributors(handlerParams, scmInstance);
            });
        }
        //2.3 Get branch history from the SCM
        promiseChain = promiseChain.then(function () {
            childLogger.info('Loading branch history.');
            return loadBranchHistory(handlerParams, scmInstance);
        });
        //2.4 Get all commits effected each file
        if (buildArguments.sendContributors) {
            promiseChain = promiseChain.then(function (mapping) {
                childLogger.info('Getting commits per file.');
                return getCommitsPerFile(handlerParams, scmInstance);
            });
        }
        //2.5 if commit was not specified, automatically detect it
        if (!buildArguments.commit) {
            promiseChain = promiseChain.then(function () {
                childLogger.info(`Couldn't find a 'commit' on the 'buildArguments'. Trying to detect the commit version.`);
                return scmInstance.detectCommitVersion(handlerParams, childLogger).then(function (commit) {
                    if (commit) {
                        handlerParams.finalOutput.meta.commit = commit;
                    }
                });
            });
        }
        //2.6 Find repository root directory
        promiseChain = promiseChain.then(function () {
            return scmInstance.getRootDirectory(handlerParams, childLogger).then(function (rootDir) {
                handlerParams.scmRootDir = rootDir;
                handlerParams.projectRoot = resolveProjectRoot(childLogger, diagnostic, buildArguments.projectRoot, handlerParams.scmRootDir);
            });
        });
        //2.6 Get list of all files in git or fs
        promiseChain = promiseChain.then(function () {
            return scmInstance.getFiles(handlerParams, childLogger).then(function (scmFiles) {
                if (scmFiles && Array.isArray(scmFiles)) {
                    return scm_files_container_1.ScmFilesContainer.createWithFiles(childLogger, scmFiles);
                }
                else {
                    return files_container_1.FilesContainer.create(childLogger, handlerParams.projectRoot, buildArguments.excludedFiles);
                }
            })
                .then(filesContainer => {
                handlerParams.filesContainer = filesContainer;
            });
        });
        // Get additional git details, like current branch and open branches if additionalGitDetails is enabled
        if (buildArguments.additionalGitDetails) {
            handlerParams.finalOutput.meta.additionalGitDetails = {
                currentBranch: null,
                openBranches: null,
                submodules: null,
            };
            promiseChain = promiseChain.then(function () {
                return scmInstance.getCurrentGitBranch(handlerParams, childLogger).then(function (currentBranch) {
                    handlerParams.finalOutput.meta.additionalGitDetails.currentBranch = currentBranch;
                });
            });
            promiseChain = promiseChain.then(function () {
                return scmInstance.getOpenGitBranches(handlerParams, childLogger).then(function (openBranches) {
                    handlerParams.finalOutput.meta.additionalGitDetails.openBranches = openBranches;
                });
            });
            // Check if workflow includes git submodules
            promiseChain = promiseChain.then(function () {
                return scmInstance.getGitSubmodules(handlerParams, childLogger).then(function (submodules) {
                    handlerParams.finalOutput.meta.additionalGitDetails.submodules = submodules;
                });
            });
        }
        return promiseChain;
    }
    function submitBuildMapping(buildArguments, finalOutput) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!buildArguments.partialBuildMapping || buildArguments.partialBuildMapping === 0) {
                return backendProxy.submitBuildMapping(finalOutput);
            }
            const startTime = (0, system_date_1.getSystemDate)();
            const chunkSize = buildArguments.partialBuildMapping;
            const files = clone(finalOutput.files);
            const staticPart = clone(finalOutput);
            staticPart.files = [];
            let partNumber = 1;
            for (let i = 0; i < files.length; i += chunkSize, partNumber += 1) {
                const filesToSend = files.slice(i, i + chunkSize);
                const chunk = Object.assign(Object.assign({}, staticPart), { files: filesToSend });
                chunk.meta.partId = partNumber;
                yield backendProxy.submitPartialBuildMapping(chunk, buildArguments.agentId, buildArguments.buildSessionId, partNumber.toString());
            }
            const endTime = (0, system_date_1.getSystemDate)();
            return backendProxy.submitBuildMappingEnd({
                agentId: buildArguments.agentId,
                status: {
                    success: true,
                    message: 'success',
                    duration: endTime.getTime() - startTime.getTime(),
                },
                labId: buildArguments.labId,
                partsCount: partNumber - 1,
            }, buildArguments.buildSessionId);
        });
    }
    function uploadBuildMetadata(cfg) {
        const blobId = 'build-config-data';
        return backendProxy.submitBlobAsync(cfg, cfg.buildSessionId, blobId, 'build-config');
    }
    function downloadBuildMetadata(buildSessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const blobs = yield backendProxy.getBlobsAsJson(buildSessionId, 'build-config');
            if (!blobs || !blobs.length) {
                logger.error(`'build-config' weren't received from a backend. Please make sure that you did a scan before`);
            }
            return blobs[0];
        });
    }
    this.run = function run(buildArguments) {
        return createBuildDiffPromiseChain(buildArguments);
    };
    this.instrument = function instrument(params, slMapper) {
        return __awaiter(this, void 0, void 0, function* () {
            childLogger.info(`Starting instrumentation. Instrumentation config: ${params}`);
            const files = getProcessedFiles(params.workspacePath, childLogger);
            const buildConfig = yield downloadBuildMetadata(params.buildSessionId);
            if (!buildConfig.useRelativeSlMapping) {
                const message = `Build was performed without 'useRelativeSlMapping' flag. Instrumentation failed. Please use the 'useRelativeSlMapping' flag in the build configuration.`;
                throw new Error(message);
            }
            if (!slMapper) {
                slMapper = resolveSlMapperInstance(params, CiaEnvVars.getSlMappingPath(), backendProxy, logger);
            }
            // We want to use the same logic for both scanning and instrumentation, so we need to set the embedCorrectUniqueId flag to the pre-configured value
            params.embedCorrectUniqueId = !!buildConfig.embedCorrectUniqueId;
            logger.info(`Embed correct uniqueId flag set to: ${params.embedCorrectUniqueId} according to the build configuration.`);
            const instrumentationParams = Object.assign(Object.assign({}, params), { files, sourceRoot: params.workspacePath, workspacepath: params.workspacePath, usebranchcoverage: false, resolveWithoutHash: true, newInstrumenter: true, experimentalSizeReduction: true, useRelativeSlMapping: true, instrumentationType: 'browser' });
            yield runBrowserInstrumentation(childLogger, instrumentationParams, slMapper);
        });
    };
    function runBrowserInstrumentation(logger, instrumentationConfig, slMapper) {
        logger.info('Running browser instrumentation.');
        instrumentationConfig.extensionsToInstrument = dvr.getFileExtensions();
        const bi = new BrowserInstrumenter(instrumentationConfig, logger, slMapper);
        return new Promise((resolve, reject) => {
            bi.instrument((err, files) => {
                if (err) {
                    childLogger.info(`Finished the instrumentation with an error. Error: ${err}`);
                }
                childLogger.info('Finished the instrumentation successfully');
                return resolve({
                    err,
                    processedFiles: files,
                });
            });
        });
    }
    function loadBranchHistory(handlerParams, scmInstance) {
        return scmInstance.getBranchHistory(handlerParams, childLogger).then(function (gitLog) {
            var _a;
            if (gitLog && gitLog.commitHistory && gitLog.commitHistory.length && gitLog.commitLog && gitLog.commitLog.length) {
                childLogger.info('Branch history loaded (' + gitLog.commitHistory.length + ' commits)');
                handlerParams.finalOutput.meta.history = gitLog.commitHistory;
                handlerParams.finalOutput.meta.commitLog = gitLog.commitLog;
                // If there are missing contributors, we need to add them to the final output
                if (((_a = gitLog.missingContributors) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    childLogger.info('Missing contributors found: ' + gitLog.missingContributors.length);
                    childLogger.info('Missing contributor emails: ' + gitLog.missingContributors.map(contributor => contributor.contributorEmail).join(', '));
                    if (!handlerParams.finalOutput.meta.contributors) {
                        handlerParams.finalOutput.meta.contributors = [];
                    }
                    handlerParams.finalOutput.meta.contributors = handlerParams.finalOutput.meta.contributors.concat(gitLog.missingContributors.map(contributor => ({
                        contributorEmail: contributor.contributorEmail,
                        contributorName: contributor.contributorName,
                    })));
                }
            }
            else {
                logBranchHistoryNotFound(gitLog, childLogger);
            }
            return loadCommitIndexMap(gitLog, handlerParams, childLogger);
        });
    }
    function getRepositoryUrl(handlerParams, scmInstance) {
        return scmInstance.getRepositoryUrl(handlerParams, childLogger).then(function (repositoryUrl) {
            if (repositoryUrl) {
                childLogger.info('Repository Url loaded (' + repositoryUrl + ')');
                handlerParams.finalOutput.meta.repositoryUrl = repositoryUrl;
            }
            return repositoryUrl;
        });
    }
    function getContributors(handlerParams, scmInstance) {
        return scmInstance.getContributors(handlerParams, childLogger).then(function (contributorsLog) {
            if (contributorsLog && contributorsLog.contributors && contributorsLog.emailToIndexMap) {
                childLogger.info('Contributors list loaded (' + contributorsLog.contributors.length + ' contributors)');
                handlerParams.finalOutput.meta.contributors = contributorsLog.contributors;
                handlerParams.emailToIndexMap = contributorsLog.emailToIndexMap;
            }
            else {
                logContributorsNotFound(contributorsLog, childLogger);
            }
            return contributorsLog;
        });
    }
    function getCommitsPerFile(handlerParams, scmInstance) {
        return scmInstance.getCommitsPerFile(handlerParams, childLogger).then(function (fileToCommitsMap) {
            if (fileToCommitsMap != null) {
                childLogger.info('File commit map loaded (' + Object.keys(fileToCommitsMap).length + ' records)');
                handlerParams.fileToCommitsMap = fileToCommitsMap;
            }
            else {
                childLogger.error('Commits map is null or undefined.');
            }
            return fileToCommitsMap;
        });
    }
}
exports.BuildDiffProcess = BuildDiffProcess;
function logContributorsNotFound(contributorsLog, logger) {
    const fieldsMap = {
        contributorsLog: !contributorsLog,
        contributors: contributorsLog && !contributorsLog.contributors,
        emailToIndexMap: contributorsLog && !contributorsLog.emailToIndexMap
    };
    const missing = utils.getMissingProperties(fieldsMap);
    logger.error(`Contributors list not loaded, missing fields: ${missing}`);
}
function logBranchHistoryNotFound(gitLog, logger) {
    const fieldsMap = {
        gitLog: !gitLog,
        commitHistory: gitLog && !gitLog.commitHistory,
        commitHistoryLength: gitLog && gitLog.commitHistory && !gitLog.commitHistory.length,
        commitLog: gitLog && !gitLog.commitLog,
        commitLogLength: gitLog && gitLog.commitLog && !gitLog.commitLog.length
    };
    const missing = utils.getMissingProperties(fieldsMap);
    logger.error(`Branch history not loaded, missing fields: ${missing}`);
}
function clone(o) {
    return JSON.parse(JSON.stringify(o));
}
function getProcessedFiles(folderToScan, logger) {
    return fileAndFolderUtils.scanDirRecursively(folderToScan, logger);
}
function loadCommitIndexMap(gitLog, handlerParams, logger) {
    if (!handlerParams.buildArguments.sendContributors) {
        return gitLog;
    }
    if (gitLog && gitLog.commitToIndexMap) {
        handlerParams.commitToIndexMap = gitLog.commitToIndexMap;
    }
    else {
        logger.error('Commit log index map not loaded');
    }
    return gitLog;
}
function createMetaTag(buildArguments) {
    return {
        generated: (0, system_date_1.getSystemDate)().valueOf(),
        build: buildArguments.build,
        commit: buildArguments.commit,
        customerId: buildArguments.customerId,
        appName: buildArguments.appname,
        technology: 'nodejs',
        branch: buildArguments.branch,
        environment: {
            agentVersion: version,
            agentType: 'nodeJsBuildScanner',
            processArgv: process.argv,
            machineName: os.hostname(),
            platform: os.platform(),
            os: os.type(),
            osVersion: os.release(),
            arch: os.arch(),
            processId: process.pid,
            ipAddress: clone(os.networkInterfaces()),
            dependencies: clone(process.versions),
            runtime: process.version
        },
        authors: buildArguments.author,
        logsUrl: buildArguments.logsUrl,
        jobName: buildArguments.jobName,
        moduleName: buildArguments.uniqueModuleId,
        uniqueModuleId: buildArguments.uniqueModuleId,
        configurationData: buildArguments,
        scmProvider: buildArguments.scmProvider,
        scmVersion: buildArguments.scmVersion,
        scmBaseUrl: buildArguments.scmBaseUrl,
        buildSessionId: buildArguments.buildSessionId,
        agentId: buildArguments.agentId,
    };
}
function countElements(files) {
    const counters = {
        methods: 0,
        branches: 0,
        files: (files === null || files === void 0 ? void 0 : files.length) || 0
    };
    files === null || files === void 0 ? void 0 : files.forEach(file => {
        var _a, _b;
        counters.methods += ((_a = file.methods) === null || _a === void 0 ? void 0 : _a.length) || 0;
        counters.branches += ((_b = file.branches) === null || _b === void 0 ? void 0 : _b.length) || 0;
    });
    return counters;
}
function resolveProjectRoot(logger, diagnosticCollector, cliOption, scmRootDir) {
    let projectRoot;
    if (cliOption) {
        const normalizedRoot = path.normalize(cliOption);
        if (utils.isAbsolutePath(normalizedRoot)) {
            // absolute path is fine
            projectRoot = normalizedRoot;
        }
        else {
            // relative path should be resolved first
            projectRoot = path.resolve(process.cwd(), normalizedRoot);
        }
        diagnosticCollector.projectRootResolved(projectRoot, contracts_1.ProjectRootSource.COMMAND_ARG);
        logger.info(`Project root set to '${projectRoot}' from 'sourceRoot'`);
    }
    else if (scmRootDir) {
        projectRoot = scmRootDir;
        diagnosticCollector.projectRootResolved(projectRoot, contracts_1.ProjectRootSource.SCM);
        logger.info(`Project root set to '${projectRoot}' same as git root`);
    }
    else {
        projectRoot = process.cwd();
        diagnosticCollector.projectRootResolved(projectRoot, contracts_1.ProjectRootSource.CWD);
        logger.info(`Project root set to '${projectRoot}' same as CWD`);
    }
    return utils.adjustPathSlashes(projectRoot);
}
//# sourceMappingURL=build-diff-process.js.map