"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPossibleMethodLocations = exports.PossibleLocation = void 0;
const create_node_key_1 = require("./create-node-key");
const ast_node_types_1 = require("./ast-node-types");
const sl_env_vars_1 = require("../../common/constants/sl-env-vars");
/**
 * When working in React, components are being generated by the "_createClass" method of the framework.
 * As a result, we have an issue when we try to map it back to source maps.
 * The method make sure to verify if a component is a React component by going through the parent nodes
 * fpr a specific node, and verifying that they have the same pattern as the expected code.
 *
 * React Code
 * ================== START CODE ============
 *  import React, { Component } from 'react';
 *  import logo from './logo.svg';
 *  import './App.css';
 *
 *  class App extends Component {
 *     someFunc(){
 *         console.log("hezi func")
 *     }
 *  }
 *
 *  export default App;
 *  ================== END CODE ============
 *
 * This code generates the following code
 *  ================== START CODE ============
 *  _createClass(App, [{
 *     key: 'someFunc',
 *     value: function someFunc() {
 *         console.log("Some func is invoked");
 *     }
 * }]);
 *  ================== END CODE ============
 *
 * So basically  we are searching for the "value" node, the array which contains it and the "_createClass" method.
 *
 * This is actually true for all classes transpiled with Babel, not only React class components.
 */
function isBabelCreateClassMethod(node, nodeToParent, recognizeBabelCreateClass) {
    if (node.type != 'FunctionExpression')
        return false;
    let key = (0, create_node_key_1.createNodeKey)(node);
    const valueNode = nodeToParent[key];
    if (valueNode == null)
        return false;
    if (valueNode.key == null || (valueNode.key != null && valueNode.key.name != 'value'))
        return false; //That's note the 'value' node. Return.
    key = (0, create_node_key_1.createNodeKey)(valueNode);
    const parent = nodeToParent[key];
    if (parent == null)
        return false;
    key = (0, create_node_key_1.createNodeKey)(parent);
    const arrayNode = nodeToParent[key];
    if (arrayNode == null || arrayNode.type != 'ArrayExpression')
        return false;
    key = (0, create_node_key_1.createNodeKey)(arrayNode);
    const createClassNode = nodeToParent[key];
    if (createClassNode == null || createClassNode.callee == null) {
        return false;
    }
    // new behavior controlled by feature flag
    if (recognizeBabelCreateClass) {
        // depending on 1) if code was minified or not 2) what tool was used for minification 3) if function names were kept during minification
        // the structure of `_createClass` call can differ
        // the following heuristic works for non-minified code transpiled by Babel, and for
        // minified versions with and without names produced by Babel, Uglify and Terser
        return isBabelCreateClassCallExpression(createClassNode) || isBabelCreateClassAssignmentExpression(createClassNode);
    }
    const result = createClassNode.callee.name == '_createClass';
    return result;
}
/**
 * For code generated by Babel (with or without minification), the `_createClass` call is always a CallExpression.
 * @param createClassNode
 */
function isBabelCreateClassCallExpression(createClassNode) {
    return createClassNode.type === 'CallExpression'
        && (
        // when function names are kept during minification we just check the name
        isCalledByCreateClassNamedFunction(createClassNode)
            // when not, we verify call arguments; there may be more arguments added by the minification tool,
            // we verify the ArrayExpressions (although we observed only a call with to arguments,
            // of which the first is Identifier and the second our _createClass argument)
            || createClassNode.arguments.some((node) => node.type === 'ArrayExpression' && isArrayExpressionMatchingCreateClassArgumentStructure(node)));
}
/**
 * For code with function names kept we can simply verify the name of a called function.
 * @param createClassNode
 */
function isCalledByCreateClassNamedFunction(createClassNode) {
    var _a, _b, _c;
    // when only transpiled with Babel, `callee` is and identifier with a name
    // when further minified, `callee` is a FunctionExpression with an id
    return ((_a = createClassNode.callee) === null || _a === void 0 ? void 0 : _a.name) == '_createClass' || ((_c = (_b = createClassNode.callee) === null || _b === void 0 ? void 0 : _b.id) === null || _c === void 0 ? void 0 : _c.name) == '_createClass';
}
/**
 * When function names are not kept during minification, we need to verify a structure of an array, if it matches what should be passed to `_createClass`.
 * @param node
 */
function isArrayExpressionMatchingCreateClassArgumentStructure(node) {
    if (node === null) {
        return false;
    }
    return node.elements.length // for empty array return false
        && node.elements.every((arrayElementNode) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            return arrayElementNode.type === 'ObjectExpression' // each element of the array is an object
                && ((_a = arrayElementNode.properties) === null || _a === void 0 ? void 0 : _a.length) === 2 // with two keys of the following names
                && ((_d = (_c = (_b = arrayElementNode.properties) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.key) === null || _d === void 0 ? void 0 : _d.name) === 'key'
                && ((_g = (_f = (_e = arrayElementNode.properties) === null || _e === void 0 ? void 0 : _e[1]) === null || _f === void 0 ? void 0 : _f.key) === null || _g === void 0 ? void 0 : _g.name) === 'value'
                && ((_k = (_j = (_h = arrayElementNode.properties) === null || _h === void 0 ? void 0 : _h[1]) === null || _j === void 0 ? void 0 : _j.value) === null || _k === void 0 ? void 0 : _k.type) === 'FunctionExpression';
        }); // value must be a function
}
/**
 * When the code is minified without keeping the names of the original functions, we can't simply check for `_createClass` call.
 * Instead, the node can be an assignment expression, which assigns an array of objects (the methods that are passed to `_createClass`)
 * to an identifier. This is further passed to `_createClass`.
 * This structure was recognized for Terser and Uglify minifications.
 * @param createClassNode
 */
function isBabelCreateClassAssignmentExpression(createClassNode) {
    var _a;
    return createClassNode.type === 'AssignmentExpression'
        && ((_a = createClassNode.right) === null || _a === void 0 ? void 0 : _a.type) === 'ArrayExpression'
        && isArrayExpressionMatchingCreateClassArgumentStructure(createClassNode.right);
}
var PositionSourceType;
(function (PositionSourceType) {
    PositionSourceType[PositionSourceType["REACT_COMPONENT"] = 50] = "REACT_COMPONENT";
    PositionSourceType[PositionSourceType["ID_LOCATION"] = 40] = "ID_LOCATION";
    PositionSourceType[PositionSourceType["ACCESSIBILITY_ADJUSTMENT"] = 35] = "ACCESSIBILITY_ADJUSTMENT";
    PositionSourceType[PositionSourceType["METHOD_BODY_LOCATION"] = 32] = "METHOD_BODY_LOCATION";
    PositionSourceType[PositionSourceType["EXPORTED_FUNCTION"] = 30] = "EXPORTED_FUNCTION";
    PositionSourceType[PositionSourceType["REGULAR_LOCATION"] = 20] = "REGULAR_LOCATION";
})(PositionSourceType || (PositionSourceType = {}));
class PossibleLocation {
    constructor(position, source) {
        this.position = position;
        this.source = source;
    }
    static fromAstLocation(astLocation, source) {
        const position = [
            astLocation.start.line,
            astLocation.start.column,
        ];
        return new PossibleLocation(position, source);
    }
}
exports.PossibleLocation = PossibleLocation;
/**
 * Get a list of possible method locations with priority for each item
 */
function getPossibleMethodLocations(node, nodeToParent, allowAccessibilityAdjustment = false, recognizeBabelCreateClass = false) {
    var _a, _b;
    const possibleLocations = [];
    if (node.type == ast_node_types_1.AstNodeTypesEnum.FunctionExpression && isBabelCreateClassMethod(node, nodeToParent, recognizeBabelCreateClass)) {
        // todo we mark all Babel methods as REACT_COMPONENT
        const possibleLocation = PossibleLocation.fromAstLocation(node.body.loc, PositionSourceType.REACT_COMPONENT);
        possibleLocations.push(possibleLocation);
    }
    /**
     * According to this link, Istanbul uses the "node.id.loc" for FunctionDeclaration and FunctionExpression.
     * https://github.com/istanbuljs/istanbuljs/blob/cbd1c1473da0dc34051c332170544529d59eda03/packages/istanbul-lib-instrument/src/visitor.js#L216
     */
    if (!sl_env_vars_1.SlEnvVars.isUseIstanbul() && shouldUseLocFromID(node) && ((_a = node.id) === null || _a === void 0 ? void 0 : _a.loc)) {
        const location = node.id.loc;
        const possibleLocation = PossibleLocation.fromAstLocation(location, PositionSourceType.ID_LOCATION);
        possibleLocations.push(possibleLocation);
    }
    /**
     * For methods transpiled by Babel we received wrong positions from sourcemaps, pointing to the end of previous method.
     * Instead, we take the beginning of the body of the method to match it during enrichment.
     * @see https://sealights.atlassian.net/browse/SLDEV-21768
     */
    if (recognizeBabelCreateClass && node.type === 'ClassMethod' && ((_b = node.body) === null || _b === void 0 ? void 0 : _b.loc)) {
        const location = node.body.loc;
        const possibleLocation = PossibleLocation.fromAstLocation(location, PositionSourceType.METHOD_BODY_LOCATION);
        possibleLocations.push(possibleLocation);
    }
    /**
     * In typescript, in case of below code, diferrent location recieved from source maps and babel parser.
     * export function foo(){
     *
     * }
     * Source maps: column 0
     * Babel parser: cloumn 7 (the 'function' woord.
     * Here we fix the location to be column 0 (export statement location)
     */
    if (node.type === ast_node_types_1.AstNodeTypesEnum.FunctionDeclaration) {
        const key = (0, create_node_key_1.createNodeKey)(node);
        const parentNode = nodeToParent[key];
        if (parentNode.type == ast_node_types_1.AstNodeTypesEnum.ExportDefaultDeclaration || parentNode.type == ast_node_types_1.AstNodeTypesEnum.ExportNamedDeclaration) {
            const possibleLocation = PossibleLocation.fromAstLocation(parentNode.loc, PositionSourceType.EXPORTED_FUNCTION);
            possibleLocations.push(possibleLocation);
        }
    }
    /**
     * In typescript, in case of below code, diferrent location recieved from source maps and babel parser for method reportMetric.
     * class DoNothing {
     *   reportSomething() {
     *     this.reportMetric('something');
     *   }
     *   private reportMetric(metric: string): void {
     *     console.log(metric);
     *   }
     * }
     * Source maps: column 2
     * Babel parser: column 10 (the 'private ' word)
     * Here we take location adjusted to accessibility keyword
     */
    if (allowAccessibilityAdjustment && node.type === ast_node_types_1.AstNodeTypesEnum.ClassMethod && node.accessibility) {
        const possibleLocation = PossibleLocation.fromAstLocation(node.loc, PositionSourceType.ACCESSIBILITY_ADJUSTMENT);
        possibleLocation.position[1] += node.accessibility.length + 1;
        possibleLocations.push(possibleLocation);
    }
    const possibleLocation = PossibleLocation.fromAstLocation(node.loc, PositionSourceType.REGULAR_LOCATION);
    possibleLocations.push(possibleLocation);
    possibleLocations.sort((a, b) => b.source - a.source);
    return possibleLocations;
}
exports.getPossibleMethodLocations = getPossibleMethodLocations;
function shouldUseLocFromID(node) {
    return node.type === ast_node_types_1.AstNodeTypesEnum.FunctionDeclaration || node.type === ast_node_types_1.AstNodeTypesEnum.FunctionExpression;
}
//# sourceMappingURL=guess-method-location.js.map