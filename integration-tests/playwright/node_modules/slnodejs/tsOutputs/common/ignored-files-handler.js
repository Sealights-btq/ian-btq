"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoredFilesHandler = void 0;
const ignore_1 = require("ignore");
const fs = require("fs");
const sl_env_vars_1 = require("./constants/sl-env-vars");
const files_utils_1 = require("./utils/files-utils");
class IgnoredFilesHandler {
    constructor(slIgnoreFilePath, outputPath, excludedPaths, filename, logger, attemptToLoadNycConfig = true) {
        this.slIgnoreFilePath = slIgnoreFilePath;
        this.outputPath = outputPath;
        this.filename = filename;
        this.logger = logger;
        this.attemptToLoadNycConfig = attemptToLoadNycConfig;
        this.isUsingNycConfig = false;
        this.loggedEntries = 0;
        this.excludedPaths = (excludedPaths === null || excludedPaths === void 0 ? void 0 : excludedPaths.split(',')) || [];
        this.initIgnorePatterns();
    }
    initIgnorePatterns() {
        this.ignoredPatterns = (0, ignore_1.default)().add(this.getRawPatterns());
    }
    getRawPatterns() {
        if (!this.slIgnoreFilePath && this.attemptToLoadNycConfig) {
            this.logger.info(`'${this.filename}' file does not exists, trying to load nyc configuration.`);
            this.rawPattern = this.readFromNycConfig();
        }
        else {
            this.rawPattern = this.readFromSlIgnoreFile();
        }
        return this.getDefaultPattern();
    }
    addCliOptionExcludedPaths(pattern) {
        this.excludedPaths.forEach(excludedPath => { pattern = this.addExcludedPath(excludedPath, pattern); });
        return pattern;
    }
    readFromSlIgnoreFile() {
        let pattern = '';
        try {
            pattern = fs.readFileSync(this.slIgnoreFilePath, 'utf8');
            this.logger.info(`Using '${this.filename}' file '${this.slIgnoreFilePath}'`);
        }
        catch (err) {
            this.logger.info(`Failed to read from: '${this.slIgnoreFilePath}'. Using default behavior.`);
        }
        return pattern;
    }
    getArrayPattern() {
        if (!this.rawPattern) {
            this.logger.info('raw pattern is empty');
            return [];
        }
        return this.rawPattern.split('\n').map(pattern => pattern.trim()).filter(pattern => pattern.length > 0);
    }
    getFormattedPattern() {
        if (!this.rawPattern) {
            return null;
        }
        return this.rawPattern.replace(/\n/g, '; ');
    }
    addExcludedPath(pattern, excludedFolder) {
        if (!excludedFolder)
            return pattern;
        if (excludedFolder && excludedFolder[excludedFolder.length - 1] != '/') { //Ensure the excludedFolder ends with / to comply with gitignore
            excludedFolder += '/';
        }
        pattern = pattern + (pattern ? '\n' : '') + excludedFolder;
        return pattern;
    }
    getDefaultPattern() {
        // default pattern - all js files under test directory and it's sub directories.
        let pattern = this.rawPattern || '';
        pattern = this.addExcludedPath(pattern, this.outputPath);
        return this.addCliOptionExcludedPaths(pattern);
    }
    readFromNycConfig() {
        try {
            const cwd = sl_env_vars_1.SlEnvVars.getBasePath() || process.cwd();
            let excludeArr;
            const rcFilePath = files_utils_1.FilesUtils.findFileUp('.nycrc', cwd) || files_utils_1.FilesUtils.findFileUp('.nycrc.json', cwd);
            const packageJsonPath = files_utils_1.FilesUtils.findFileUp('package.json', cwd);
            if (rcFilePath) {
                this.logger.debug(`Reading nyc exclude from '${rcFilePath}'`);
                excludeArr = this.readNycConfig(rcFilePath, false);
            }
            else if (packageJsonPath) {
                this.logger.debug(`Reading nyc exclude from '${packageJsonPath}'`);
                excludeArr = this.readNycConfig(packageJsonPath, true);
            }
            return this.createExcludePatternFromNyc(excludeArr);
        }
        catch (err) {
            this.logger.warn(`Error while trying to read nyc configuration. Error: ${err}`);
            return null;
        }
    }
    readNycConfig(file, isPackageJson) {
        const fileContent = fs.readFileSync(file);
        const configObject = JSON.parse(fileContent.toString());
        const nycConfig = isPackageJson ? configObject.nyc : configObject;
        if (nycConfig) {
            return nycConfig.exclude;
        }
        return null;
    }
    createExcludePatternFromNyc(excludeArr) {
        if (!excludeArr) {
            this.logger.info('No files to exclude in nyc configuration');
            return null;
        }
        this.isUsingNycConfig = true;
        this.logger.debug('Found the following exclude patterns: ' + JSON.stringify(excludeArr, null, '\t'));
        return excludeArr.join('\n');
    }
    denies(input) {
        try {
            return this.ignoredPatterns.ignores(input);
        }
        catch (e) {
            // TODO: report OBD
            if (this.loggedEntries < IgnoredFilesHandler.MAX_ENTRIES_TO_LOG) {
                this.logger.warn(`Slignore - Error thrown while checking file '${input}', Error: ${e.message}`);
                this.logger.debug(e);
                this.loggedEntries++;
            }
            return false;
        }
    }
    accepts(input) {
        return !this.denies(input);
    }
}
exports.IgnoredFilesHandler = IgnoredFilesHandler;
IgnoredFilesHandler.SCAN_IGNORE_FILE_NAME = '.slignore';
IgnoredFilesHandler.GENERATED_IGNORE_FILE_NAME = '.slignore.generated';
IgnoredFilesHandler.INSTRUMENT_IGNORE_FILE_NAME = '.slignore.instrument';
IgnoredFilesHandler.MAX_ENTRIES_TO_LOG = 10;
//# sourceMappingURL=ignored-files-handler.js.map