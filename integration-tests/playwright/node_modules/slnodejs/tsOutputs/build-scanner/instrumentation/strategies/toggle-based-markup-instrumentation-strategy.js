"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToggleBasedMarkupInstrumentationStrategy = void 0;
const fs = require("fs");
const markup_instrumnetation_strategy_1 = require("./markup-instrumnetation-strategy");
const markup_instrumnetation_strategy_2 = require("./markup-instrumnetation-strategy");
const strategy_utils_1 = require("./strategy-utils");
/**
 * This strategy implements the toggle-based browser instrumentation approach for markup files.
 * It modifies the original file to contain both instrumented and non-instrumented versions of scripts,
 * toggling between them based on the presence of sl-preamble-config.js
 */
class ToggleBasedMarkupInstrumentationStrategy extends markup_instrumnetation_strategy_1.MarkupFileInstrumentationStrategy {
    process(inputFile, outputFile, fileKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const singleMarkupFileInstrumenter = new markup_instrumnetation_strategy_2.SingleMarkupFileInstrumenter(this.logger);
            // Extract and process scripts
            singleMarkupFileInstrumenter.extractScripts(inputFile);
            if (!singleMarkupFileInstrumenter.hasJsInFile()) {
                throw new Error("No script tags. Nothing to instrument");
            }
            // Get original scripts
            const originalScripts = singleMarkupFileInstrumenter.originalScriptTags;
            // Create instrumented version of the scripts
            singleMarkupFileInstrumenter.markScripts();
            const jsContent = singleMarkupFileInstrumenter.getAllJsInFile();
            const instrumentedJsContent = this.instrumenter.instrumentContent(jsContent, fileKey);
            // Create the toggle-based content
            const toggleContent = this.createToggleContent(singleMarkupFileInstrumenter.originalFileContent, originalScripts, instrumentedJsContent);
            fs.writeFileSync(outputFile, toggleContent, "utf8");
        });
    }
    createToggleContent(originalContent, originalScripts, instrumentedContent) {
        let modifiedContent = originalContent;
        // Extract coverage initialization from the instrumented content
        const firstTagMarker = (0, strategy_utils_1.createScriptMarker)(0);
        const firstTagStart = instrumentedContent.indexOf(firstTagMarker);
        const coverageInitScript = instrumentedContent
            .substring(0, firstTagStart)
            .trim();
        // Add initialization check and coverage initialization at the beginning of head
        const headStart = modifiedContent.indexOf("<head>");
        if (headStart === -1) {
            this.logger.warn(`No <head> tag found in the file. Cannot add coverage initialization.`);
            return modifiedContent;
        }
        const initializationScript = `
<script type="text/javascript">
    // Sealights Toggle-Based Instrumentation
    let useInstrumented = false;
    try {
        if (typeof window !== 'undefined') {
            const xhr = new XMLHttpRequest();
            xhr.open('HEAD', '/sl-preamble-config.js', false);
            xhr.send();
            if (xhr.status === 200) {
                useInstrumented = true;
            }
        }
    } catch (e) {
        console.error('Sealights: Error checking for sl-preamble-config.js', e);
    }
    ${coverageInitScript}
</script>`;
        modifiedContent =
            modifiedContent.slice(0, headStart + 6) +
                initializationScript +
                modifiedContent.slice(headStart + 6);
        // Replace each script with conditional wrapper
        for (let i = 0; i < originalScripts.length; i++) {
            const currentTag = originalScripts[i];
            if (!currentTag.content.trim())
                continue; // Skip empty scripts
            const scriptMarker = (0, strategy_utils_1.createScriptMarker)(i);
            // Extract the original script content and attributes
            const originalScriptContent = currentTag.content;
            const originalScriptAttributes = currentTag.attributes || "";
            // Extract the instrumented script content
            let scriptStartIndex = instrumentedContent.indexOf(scriptMarker);
            if (scriptStartIndex === -1) {
                this.logger.warn(`Could not find script marker ${i} in instrumented content`);
                continue;
            }
            scriptStartIndex += scriptMarker.length;
            const scriptEndIndex = instrumentedContent.lastIndexOf(scriptMarker);
            if (scriptEndIndex === -1) {
                this.logger.warn(`Could not find end marker for script ${i} in instrumented content`);
                continue;
            }
            const instrumentedScriptContent = instrumentedContent
                .substring(scriptStartIndex, scriptEndIndex)
                .trim();
            if (!instrumentedScriptContent) {
                this.logger.warn(`Empty instrumented content for script ${i}`);
                continue;
            }
            // Create wrapper with both versions in the same script tag
            const scriptWrapper = `
      <script ${originalScriptAttributes}>
        if (useInstrumented) {
          ${instrumentedScriptContent}
        } else {
          ${originalScriptContent}
        }
      </script>`;
            // Replace the original script tag with our wrapper
            const scriptTagRegex = new RegExp(`<script[^>]*>${escapeRegExp(originalScriptContent)}</script>`, "g");
            modifiedContent = modifiedContent.replace(scriptTagRegex, scriptWrapper);
        }
        return modifiedContent;
    }
}
exports.ToggleBasedMarkupInstrumentationStrategy = ToggleBasedMarkupInstrumentationStrategy;
// Helper function to escape special characters for regex
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
//# sourceMappingURL=toggle-based-markup-instrumentation-strategy.js.map