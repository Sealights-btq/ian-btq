"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnsureFilesHandlerService = void 0;
const files_data_container_1 = require("./files-data-container");
const path_1 = require("path");
const ActualFile = require("../file-system/actual-file");
const file_element_utils_1 = require("./file-element-utils");
const file_enricher_1 = require("./file-enricher");
const SourceFileNotifier = require("../js_diff/source-files-notifier");
const utils = require("../utils");
const ignored_files_handler_1 = require("../../common/ignored-files-handler");
const data_cleansing_utils_1 = require("../../common/utils/data-cleansing-utils");
const fs_1 = require("fs");
const source_map_config_dto_1 = require("../../common/source-map-config-dto");
class EnsureFilesHandlerService {
    constructor(logger, opts, filesContainer, filePathFixer, scmRootDir, config, fileToCommitsMap, diagnostic) {
        this.logger = logger;
        this.opts = opts;
        this.filesContainer = filesContainer;
        this.filePathFixer = filePathFixer;
        this.scmRootDir = scmRootDir;
        this.config = config;
        this.fileToCommitsMap = fileToCommitsMap;
        this.diagnostic = diagnostic;
        this.WEBPACK_PREFIX = 'webpack:///';
        this.WEBPACK_BOOTSTRAP_FILE = 'webpack/bootstrap';
        this.WEBPACK_LAZY_FILE = '$_lazy';
        this.WEBPACK_SRC_ASYNC = 'src async';
        this.WEBPACK_SRC_LAZY = 'src lazy';
        this.WEBPACK_RESOURCE_SIGN = '~'; // Webpack replace 'node_modules' with '~'
        this.NODE_MODULES = 'node_modules';
        this.THIRD_PARTIES_FOLDERS = [
            this.WEBPACK_BOOTSTRAP_FILE,
            this.WEBPACK_LAZY_FILE,
            this.WEBPACK_RESOURCE_SIGN,
            this.NODE_MODULES,
            this.WEBPACK_SRC_ASYNC,
            this.WEBPACK_SRC_LAZY
        ];
        this.filesDataContainer = new files_data_container_1.FilesDataContainer();
        this.sourceFilesNotifier = new SourceFileNotifier(logger);
    }
    ensureProcess(req) {
        const filesToAppendUniqueId = [];
        const result = Object.assign(Object.assign({}, req), { files: [] });
        if (this.config.removeSensitiveData) {
            result.meta = data_cleansing_utils_1.DataCleansingUtils.removeSensitiveData(req.meta);
        }
        for (const scannedFile of req.files) {
            const actualScannedFileObject = new ActualFile(scannedFile.logicalPath, scannedFile.absolutePath, source_map_config_dto_1.SourceMapConfigDto.from(this.config));
            this.handleMappingOneFile(scannedFile, actualScannedFileObject);
            // Only append unique id details if autoResolveProjectRoot is true and the file has methods so we don't write to the file unnecesarily
            // This is done in two-stages on purpose, because at this stage we already have the content so we don't need to read it again later on
            // But at this stage we don't have the uniqueIdKey so we need to read it again later on, which is a cheaper operation
            if (this.opts.autoResolveProjectRoot && scannedFile.methods.length > 0) {
                filesToAppendUniqueId.push({
                    absolutePath: scannedFile.absolutePath,
                    physicalPath: scannedFile.physicalPath,
                    content: actualScannedFileObject.getContent(),
                });
            }
        }
        result.files = this.filesDataContainer.files;
        result.files = this.filePathFixer.fixFilePathes(result.files);
        this.setCommitIndexes(result.files);
        this.filterIgnoredSourceFiles(result);
        const enricher = file_enricher_1.FileEnricherFactory.initByConfig(this.logger, this.diagnostic, this.opts, this.scmRootDir, this.filesContainer, this.config);
        const resultAfterEnrich = enricher.enrichFiles(result);
        this.deleteRedundantFields(resultAfterEnrich);
        if (this.config.excludeNestedMethods) {
            this.deleteNestedAnonymousMethods(resultAfterEnrich);
        }
        filesToAppendUniqueId.forEach((fileDetails) => {
            const uniqueMethodsIdPrefixes = new Set(resultAfterEnrich.files.reduce((accumulator, current) => {
                if (current.transpiledFile === fileDetails.physicalPath) {
                    return [...accumulator, ...current.methods.map(method => method.uniqueId.split('@')[0])];
                }
                return accumulator;
            }, []));
            this.appendUniqueIdsToFile(fileDetails.absolutePath, fileDetails.content, Array.from(uniqueMethodsIdPrefixes));
        });
        return { output: resultAfterEnrich };
    }
    /**
     * At the bottom of the file add a new line with a comment of the format // SL_UNIQUE_ID_KEYS: {uniqueIdKey1},{uniqueIdKey2}
     * We use this to construct the footprints during the coverage-listening stage by taking the uniqueIdKey from the file itself and adding just the method position
     * Since path calculations can be unreliable due to transformations we use uniqueMethodIdPrefixes which we are sure is the final format of the uniqueIds
    */
    appendUniqueIdsToFile(absolutePath, fileContent, uniqueMethodIdPrefixes) {
        try {
            const uniqueIdKeys = uniqueMethodIdPrefixes.join(',');
            this.logger.debug(`Appending uniqueIds to file ${absolutePath} with uniqueIdKeys ${uniqueIdKeys}`);
            (0, fs_1.writeFileSync)(absolutePath, fileContent + `\n// SL_UNIQUE_ID_KEYS: ${uniqueIdKeys}`);
        }
        catch (e) {
            this.logger.error(`Error appending uniqueIds to file ${absolutePath}: ${e}. This might result in no coverage for this file in the coverage-listening stage.`);
        }
    }
    filterIgnoredSourceFiles(result) {
        const ignoredFilesHandler = utils.createSlIgnore(ignored_files_handler_1.IgnoredFilesHandler.GENERATED_IGNORE_FILE_NAME, this.opts, this.logger);
        result.files = result.files.filter(file => {
            if (ignoredFilesHandler.denies(file.physicalPath)) {
                this.logger.info(`File ${file.absolutePath} is ignored`);
                this.diagnostic.generatedFileIgnored(file.absolutePath);
                return false;
            }
            return true;
        });
    }
    deleteRedundantFields(output) {
        output.files.forEach(f => {
            f.methods.forEach(m => { var _a; return (_a = m === null || m === void 0 ? void 0 : m.meta) === null || _a === void 0 ? true : delete _a.identifierPosition; });
        });
    }
    deleteNestedAnonymousMethods(output) {
        output.files = output.files.map(f => {
            f.methods = f.methods.filter(m => {
                return !f.methods.find(x => {
                    if (m === x) {
                        return false;
                    }
                    const isStartPositionLineBigger = x.position[0] < m.position[0];
                    const isStartPositionColumnBigger = x.position[0] === m.position[0] && x.position[1] <= m.position[1];
                    const isEndPositionLineLess = x.endPosition[0] > m.endPosition[0];
                    const isEndPositionColumnLess = x.endPosition[0] === m.endPosition[0] && x.endPosition[1] >= m.endPosition[1];
                    const isStartPositionBigger = isStartPositionLineBigger || isStartPositionColumnBigger;
                    const isEndPositionLess = isEndPositionLineLess || isEndPositionColumnLess;
                    return isStartPositionBigger && isEndPositionLess;
                });
            });
            return f;
        });
    }
    setCommitIndexes(files) {
        files.forEach((file) => { var _a; return file.commitIndexes = ((_a = this.fileToCommitsMap) === null || _a === void 0 ? void 0 : _a[file.physicalPath]) || []; });
    }
    // generatedFile - bundle/result of transpilation
    handleMappingOneFile(scannedFileData, scannedFileObject) {
        var _a;
        const sourceMaps = scannedFileObject.readSourceMapsWithRaw(this.logger);
        if (!sourceMaps.consumer) {
            this.diagnostic.fileWithoutSourceMap(scannedFileData.absolutePath);
            this.filesDataContainer.addFile(scannedFileData);
        }
        else {
            this.diagnostic.fileWithSourceMap(scannedFileData.absolutePath);
            this.diagnostic.fileWithSourceMapConsumer(scannedFileData.absolutePath, sourceMaps.consumer);
            const codeElementMetrics = { hasColumnInfo: false };
            this.addMethods(scannedFileData, sourceMaps.consumer, codeElementMetrics);
            this.addBranches(scannedFileData, sourceMaps.consumer, codeElementMetrics);
            this.sourceFilesNotifier.notifySources((_a = sourceMaps.rawSourceMaps) === null || _a === void 0 ? void 0 : _a.sources, scannedFileData.absolutePath, codeElementMetrics.hasColumnInfo);
        }
    }
    trimWebpackPrefix(source) {
        if (source.indexOf(this.WEBPACK_PREFIX) === 0) {
            source = source.substring(this.WEBPACK_PREFIX.length);
        }
        return source;
    }
    cleanPath(source) {
        source = this.trimWebpackPrefix(source);
        if (source.indexOf('/') === 0) {
            source = source.substring(1);
        }
        return (0, path_1.normalize)(source);
    }
    getMappingPositionForMethod(sourceMaps, method) {
        var _a, _b;
        const startMap = sourceMaps.originalPositionFor({
            line: method.position[0],
            column: method.position[1]
        });
        const endMap = sourceMaps.originalPositionFor({
            line: method.endPosition[0],
            column: method.endPosition[1]
        });
        const identifierPosition = sourceMaps.originalPositionFor({
            line: (_a = method === null || method === void 0 ? void 0 : method.meta) === null || _a === void 0 ? void 0 : _a.identifierPosition[0],
            column: (_b = method === null || method === void 0 ? void 0 : method.meta) === null || _b === void 0 ? void 0 : _b.identifierPosition[1]
        });
        return { startMap, endMap, identifierPosition };
    }
    getMappingPositionForBranch(sourceMaps, branch) {
        const startMap = sourceMaps.originalPositionFor({
            line: branch.position[0],
            column: branch.position[1]
        });
        const parentStartMap = sourceMaps.originalPositionFor({
            line: branch.parentPosition[0],
            column: branch.parentPosition[1]
        });
        const endMap = sourceMaps.originalPositionFor({
            line: branch.endPosition[0],
            column: branch.endPosition[1]
        });
        return { startMap, endMap, parentStartMap };
    }
    addMethods(scannedFileData, sourceMaps, codeElementMetrics) {
        for (const method of scannedFileData.methods) {
            const { startMap, endMap, identifierPosition } = this.getMappingPositionForMethod(sourceMaps, method);
            if (identifierPosition) {
                method.meta.identifierPosition = [identifierPosition.line, identifierPosition.column];
            }
            if (this.isMapValid(startMap)) {
                if (+startMap.column !== 0) {
                    codeElementMetrics.hasColumnInfo = true;
                }
                const cleanPath = this.cleanPath(startMap.source);
                const mappedMethod = (0, file_element_utils_1.createMethod)(startMap, endMap, method, method.uniqueIdKey, this.diagnostic);
                this.filesDataContainer.addMethod(cleanPath, scannedFileData.logicalPath, mappedMethod);
                this.diagnostic.addMappedMethod(scannedFileData.absolutePath, cleanPath, mappedMethod);
            }
        }
    }
    addBranches(generatedFile, sourceMaps, codeElementMetrics) {
        for (const branch of generatedFile.branches) {
            const branchInfo = branch;
            const { startMap, endMap, parentStartMap } = this.getMappingPositionForBranch(sourceMaps, branch);
            if (this.isMapValid(startMap)) {
                if (+startMap.column !== 0) {
                    codeElementMetrics.hasColumnInfo = true;
                }
                const cleanPath = this.cleanPath(startMap.source);
                this.filesDataContainer.addBranch(cleanPath, generatedFile.logicalPath, (0, file_element_utils_1.createBranch)(startMap, endMap, parentStartMap, branchInfo, cleanPath, branch.uniqueIdKey));
            }
        }
    }
    isMapValid(map) {
        if (!map.source) {
            return false;
        }
        const mapFix = this.trimWebpackPrefix(map.source);
        return mapFix && !this.THIRD_PARTIES_FOLDERS.some(str => mapFix.includes(str));
    }
}
exports.EnsureFilesHandlerService = EnsureFilesHandlerService;
//# sourceMappingURL=ensure-files-handler.service.js.map