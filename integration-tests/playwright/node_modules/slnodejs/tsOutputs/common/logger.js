"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IpcTransport = exports.BufferingLogger = exports.LoggerFactory = exports.LogLevels = void 0;
const winston = require("winston");
const Transport = require("winston-transport");
const stream_1 = require("stream");
const os_1 = require("os");
const contracts_1 = require("./contracts");
const system_date_1 = require("./system-date");
const contracts_2 = require("../build-scanner/instrumentation/process-pool/contracts");
const isLogsOff = () => process.env['SL_LOG_LEVEL'] === LogLevels.OFF;
var LogLevels;
(function (LogLevels) {
    LogLevels["LIFECYCLE"] = "lifecycle";
    LogLevels["ERROR"] = "error";
    LogLevels["WARN"] = "warn";
    LogLevels["INFO"] = "info";
    LogLevels["HTTP"] = "http";
    LogLevels["VERBOSE"] = "verbose";
    LogLevels["DEBUG"] = "debug";
    LogLevels["SILLY"] = "silly";
    LogLevels["OFF"] = "off";
})(LogLevels = exports.LogLevels || (exports.LogLevels = {}));
function getLevels() {
    const levels = {};
    levels[LogLevels.LIFECYCLE] = 0;
    levels[LogLevels.ERROR] = 1;
    levels[LogLevels.WARN] = 2;
    levels[LogLevels.INFO] = 3;
    levels[LogLevels.HTTP] = 4;
    levels[LogLevels.VERBOSE] = 5;
    levels[LogLevels.DEBUG] = 6;
    levels[LogLevels.SILLY] = 7;
    return levels;
}
class LoggerFactory {
    constructor() {
    }
    static getCreateBufferingLogger() {
        if (this.bufferingLogger == null) {
            this.bufferingLogger = new BufferingLogger({});
        }
        return this.bufferingLogger;
    }
    static getCreateApplicationLogger(cfg) {
        if (!this.logger) {
            this.logger = this.createLogger(cfg);
        }
        return this.logger;
    }
    static getCreateDebugFileLogger(filename) {
        const fileTransport = new winston.transports.File({ level: LogLevels.DEBUG, filename, format: getJsonFormat() });
        if (!this.logger) {
            const levels = getLevels();
            const transports = [];
            transports.push(fileTransport);
            this.logger = winston.createLogger({ transports, levels });
        }
        else {
            this.logger.add(fileTransport);
        }
        return this.logger;
    }
    static getCreateSubprocessLogger(subprocess) {
        const ipcTransport = new IpcTransport(subprocess, {
            format: getSubprocessFormat(subprocess.pid),
            level: getLogLevel(),
        });
        if (!this.subprocessLogger) {
            const logger = this.createLogger();
            this.subprocessLogger = logger
                .clear()
                .add(ipcTransport);
        }
        return this.subprocessLogger;
    }
    // Added for tests
    static reset() {
        this.logger = null;
        this.bufferingLogger = null;
    }
    static createLogger(cfg) {
        var _a;
        const silent = isLogsOff();
        const loggers = getLoggerTypes((_a = cfg === null || cfg === void 0 ? void 0 : cfg.loggers) === null || _a === void 0 ? void 0 : _a.value);
        const transports = mapLoggersToTransports(loggers, silent);
        if (transports.length === 0) {
            transports.push(getConsoleTransport(loggers, silent));
        }
        const remoteStream = this.getCreateBufferingLogger();
        transports.push(new winston.transports.Stream({
            stream: remoteStream,
            format: getJsonFormat(),
            level: getLogLevel(),
            silent: false,
        }));
        return winston.createLogger({ transports, levels: getLevels() });
    }
}
exports.LoggerFactory = LoggerFactory;
class BufferingLogger extends stream_1.Writable {
    constructor(config) {
        super();
        this.config = config;
        this.acceptLogs = true;
        this.buffer = [];
        this.bufferLength = config.bufferLength || 50;
    }
    write(data) {
        if (!this.acceptLogs) {
            return true;
        }
        // Parse the data to json (it receives as string)
        this.buffer.push(JSON.parse(data));
        this.checkBuffer(false);
    }
    processBuffer() {
        if (this.buffer.length == 0) {
            return false;
        }
        const entries = this.buffer.splice(0, this.buffer.length);
        if (entries.length > 0) {
            this.emit('log_buffer_full', entries);
        }
        return true;
    }
    stop() {
        this.acceptLogs = false;
    }
    checkBuffer(inShutdown) {
        if (!this.buffer.length) {
            return false; //Nothing more to send
        }
        if (inShutdown || this.buffer.length >= this.bufferLength) {
            return this.processBuffer();
        }
    }
}
exports.BufferingLogger = BufferingLogger;
class IpcTransport extends Transport {
    constructor(subprocess, options) {
        super(options);
        this.subprocess = subprocess;
    }
    log(info, callback) {
        var _a, _b;
        (_b = (_a = this.subprocess).send) === null || _b === void 0 ? void 0 : _b.call(_a, {
            type: contracts_2.PROCESS_MESSAGE_TYPE.LOG,
            payload: {
                level: info.level,
                message: info.message,
                label: info.label,
            },
        });
        callback();
    }
}
exports.IpcTransport = IpcTransport;
function getJsonFormat() {
    return winston.format.combine(winston.format.splat(), winston.format.simple(), winston.format.label({ label: `NodeJS-Agent[${process.pid}]` }), winston.format.timestamp({ format: () => (0, system_date_1.getSystemDate)().toISOString().substr(11) }), winston.format.printf((info) => {
        return JSON.stringify({
            timestamp: info['timestamp'],
            name: info['label'],
            hostname: (0, os_1.hostname)(),
            pid: process.pid,
            component: info['component'] || 'main',
            level: info.level.toUpperCase(),
            msg: info.message,
        });
    }));
}
function getConsoleFormat() {
    const colorizer = winston.format.colorize();
    colorizer.addColors({ lifecycle: 'white' });
    return winston.format.combine(winston.format.splat(), winston.format.simple(), winston.format.label({ label: 'NodeJS-Agent' }), winston.format.timestamp({ format: () => (0, system_date_1.getSystemDate)().toISOString().substr(11) }), winston.format.printf((info) => {
        return colorizer.colorize(info.level, `${info.timestamp} ${info.level.toUpperCase()} ${info.label}: ${info.message}`);
    }));
}
function getSubprocessFormat(pid) {
    return winston.format.combine(winston.format.splat(), winston.format.label({ label: `Subprocess [${pid}]` }));
}
function getLogLevel() {
    return process.env.SL_LOG_LEVEL && !isLogsOff() ? process.env.SL_LOG_LEVEL.toLowerCase() : LogLevels.INFO;
}
function getConsoleLogLevel(loggers) {
    if (!logToConsole(loggers)) {
        return LogLevels.LIFECYCLE;
    }
    return getLogLevel();
}
function getNodeDebugLowercase() {
    var _a, _b;
    return (_b = (_a = process.env['NODE_DEBUG']) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : '';
}
function logToConsole(loggers) {
    return loggers.indexOf('console') >= 0;
}
function getLoggerTypes(loggerTypesFromConfig) {
    const parsedLoggerTypesFromEnv = getNodeDebugLowercase()
        .split(',')
        .map((type) => ({
        'sl': 'console',
        'sl-console': 'console',
        'sl-file': 'file',
    }[type]));
    const parsedLoggerTypesFromConfig = (loggerTypesFromConfig !== null && loggerTypesFromConfig !== void 0 ? loggerTypesFromConfig : '').split(',');
    const loggerTypes = Array.from(new Set([...parsedLoggerTypesFromConfig, ...parsedLoggerTypesFromEnv]));
    return loggerTypes.filter((loggerType) => contracts_1.AVAILABLE_LOGGER_TYPES.includes(loggerType));
}
function getConsoleTransport(loggers, silent) {
    return new winston.transports.Console({
        level: getConsoleLogLevel(loggers),
        format: getConsoleFormat(),
        silent,
    });
}
function mapLoggersToTransports(loggers, silent) {
    const mapper = (loggerType) => ({
        'file': () => {
            var _a;
            return new winston.transports.File({
                level: getLogLevel(),
                format: getJsonFormat(),
                filename: (_a = process.env['SL_LOG_OUTPUT_FILE']) !== null && _a !== void 0 ? _a : 'sl.node.log',
            });
        },
        'console': () => getConsoleTransport(loggers, silent),
    }[loggerType]());
    return loggers.map(mapper);
}
//# sourceMappingURL=logger.js.map